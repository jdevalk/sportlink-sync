---
phase: 21-conflict-resolution-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/conflict-resolver.js
  - lib/stadion-db.js
autonomous: true

must_haves:
  truths:
    - "Conflict resolver compares Sportlink and Stadion timestamps to determine winner"
    - "Grace period (5 seconds) causes Sportlink to win on near-ties"
    - "NULL timestamps handled correctly (system with history wins)"
    - "Conflicts detected at field level, not whole record"
    - "Conflict resolutions logged to audit table"
    - "Conflict summary can be generated for email reports"
  artifacts:
    - path: "lib/conflict-resolver.js"
      provides: "Conflict detection and resolution logic"
      exports: ["resolveFieldConflicts", "generateConflictSummary"]
      min_lines: 100
    - path: "lib/stadion-db.js"
      provides: "conflict_resolutions audit table"
      contains: "CREATE TABLE IF NOT EXISTS conflict_resolutions"
  key_links:
    - from: "lib/conflict-resolver.js"
      to: "lib/sync-origin.js"
      via: "import compareTimestamps, TRACKED_FIELDS, getTimestampColumnNames"
      pattern: "require.*sync-origin"
    - from: "lib/conflict-resolver.js"
      to: "lib/stadion-db.js"
      via: "logConflictResolution inserts to audit table"
      pattern: "INSERT INTO conflict_resolutions"
---

<objective>
Create the conflict resolution infrastructure for bidirectional sync using last-write-wins (LWW) logic at the field level.

Purpose: Enable the system to detect when both Sportlink and Stadion have modified the same field and automatically resolve using timestamp comparison. This is the foundation for reverse sync (Phases 22-24).

Output:
- lib/conflict-resolver.js - Conflict detection and resolution module
- Updated lib/stadion-db.js - Adds conflict_resolutions audit table
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-conflict-resolution-infrastructure/21-CONTEXT.md
@.planning/phases/21-conflict-resolution-infrastructure/21-RESEARCH.md
@.planning/phases/20-foundation/20-01-SUMMARY.md
@lib/sync-origin.js
@lib/stadion-db.js
@lib/logger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conflict_resolutions audit table to stadion-db.js</name>
  <files>lib/stadion-db.js</files>
  <action>
Add conflict_resolutions audit table schema to initDb() function. Follow the existing incremental migration pattern (PRAGMA table_info check before ALTER TABLE).

Table schema:
```sql
CREATE TABLE IF NOT EXISTS conflict_resolutions (
  id INTEGER PRIMARY KEY,
  knvb_id TEXT NOT NULL,
  field_name TEXT NOT NULL,
  sportlink_value TEXT,
  stadion_value TEXT,
  sportlink_modified TEXT,
  stadion_modified TEXT,
  winning_system TEXT NOT NULL,
  resolution_reason TEXT NOT NULL,
  resolved_at TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_conflict_resolutions_knvb
  ON conflict_resolutions (knvb_id);

CREATE INDEX IF NOT EXISTS idx_conflict_resolutions_resolved
  ON conflict_resolutions (resolved_at);
```

Also add helper functions at the bottom of the module (before module.exports):

1. `logConflictResolution(db, resolution)` - Insert a single conflict resolution record
   - resolution object: { knvb_id, field_name, sportlink_value, stadion_value, sportlink_modified, stadion_modified, winning_system, resolution_reason }
   - resolved_at is set to current ISO timestamp

2. `getConflictResolutions(db, since)` - Get conflict resolutions since a timestamp
   - If since is null, return all resolutions
   - Order by resolved_at DESC
   - Returns array of resolution records

3. `getConflictResolutionCount(db, since)` - Get count of resolutions since timestamp
   - If since is null, return total count

Export all three new functions in module.exports.
  </action>
  <verify>
Run: `node -e "const db = require('./lib/stadion-db'); const d = db.openDb(':memory:'); console.log('table exists:', d.prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name='conflict_resolutions'\").get() !== undefined)"`

Expected output: `table exists: true`
  </verify>
  <done>
conflict_resolutions table exists in schema with indexes, logConflictResolution/getConflictResolutions/getConflictResolutionCount functions exported and working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conflict-resolver.js module</name>
  <files>lib/conflict-resolver.js</files>
  <action>
Create lib/conflict-resolver.js with the following functions:

1. `resolveFieldConflicts(member, sportlinkData, stadionData, db, logger)`:
   - Takes: member row from stadion_members (with timestamp columns), sportlinkData object, stadionData object, db connection, optional logger
   - For each field in TRACKED_FIELDS:
     - Get timestamp column names using getTimestampColumnNames(field)
     - Read sportlinkTs = member[cols.sportlink], stadionTs = member[cols.stadion]
     - Handle NULL timestamps per 21-CONTEXT.md:
       - Both NULL: use sportlinkData[field] (forward sync default), no conflict
       - Only sportlink has timestamp: use sportlinkData[field], no conflict
       - Only stadion has timestamp: use stadionData[field], no conflict
       - Both have timestamps: proceed with conflict detection
     - Use compareTimestamps(stadionTs, sportlinkTs, 5000):
       - 0 (within grace period): Sportlink wins (per 21-CONTEXT.md)
       - 1 (stadion newer): Stadion wins
       - -1 (sportlink newer): Sportlink wins
     - If values differ AND timestamps indicate different winners, it's a conflict
     - Log conflict to audit table via logConflictResolution()
   - Returns: { resolutions: Map<field, {value, winner, reason}>, conflicts: Array<ConflictRecord> }

2. `generateConflictSummary(conflicts)`:
   - Takes: array of conflict records (from resolveFieldConflicts or getConflictResolutions)
   - If empty array, return null
   - Groups conflicts by knvb_id
   - Returns plain text summary formatted for existing email system:
     ```
     CONFLICTS DETECTED AND RESOLVED

     Total conflicts: N
     Members affected: M

     RESOLUTION DETAILS

     - KNVB123: 2 field(s)
       email: stadion won (stadion_newer)
       mobile: sportlink won (grace_period)
     - KNVB456: 1 field(s)
       phone: stadion won (stadion_newer)
     ```
   - This format is compatible with formatAsHtml() in send-email.js

Use module/CLI hybrid pattern:
```javascript
async function resolveFieldConflicts(...) { ... }
function generateConflictSummary(...) { ... }

module.exports = { resolveFieldConflicts, generateConflictSummary };

if (require.main === module) {
  // CLI: node lib/conflict-resolver.js --test
  // Runs basic self-test with mock data
}
```

Resolution reason values (use these exact strings for consistency):
- 'both_null_sportlink_default' - Both NULL, using Sportlink
- 'only_sportlink_has_history' - Sportlink has timestamp, Stadion doesn't
- 'only_stadion_has_history' - Stadion has timestamp, Sportlink doesn't
- 'grace_period_sportlink_wins' - Within 5s tolerance, Sportlink wins
- 'sportlink_newer' - Sportlink timestamp is newer by >5s
- 'stadion_newer' - Stadion timestamp is newer by >5s
- 'values_match_no_conflict' - Timestamps differ but values are same
  </action>
  <verify>
Run: `node lib/conflict-resolver.js --test`

This should run the built-in self-test and output:
- Test results for NULL handling
- Test results for grace period
- Test results for conflict detection
- All tests should pass
  </verify>
  <done>
lib/conflict-resolver.js exists with resolveFieldConflicts and generateConflictSummary functions. Self-test passes demonstrating correct behavior for NULL handling, grace period, and conflict detection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration with existing utilities</name>
  <files>lib/conflict-resolver.js</files>
  <action>
Create a verification script that tests the full integration:

Run: `node -e "...integration test code..."` that:
1. Creates in-memory database with openDb(':memory:')
2. Manually inserts a test member with timestamp columns populated
3. Calls resolveFieldConflicts with mock sportlink/stadion data
4. Verifies conflict_resolutions table has expected records
5. Calls generateConflictSummary and verifies output format

This verifies:
- sync-origin.js utilities work correctly (compareTimestamps, TRACKED_FIELDS)
- stadion-db.js audit functions work (logConflictResolution, getConflictResolutions)
- conflict-resolver.js integrates all pieces
- Summary format is compatible with email system

The test should be self-contained (no external dependencies beyond the codebase).
  </action>
  <verify>
Run the integration test. Expected output should show:
- Member inserted with timestamps
- Conflicts detected and resolved
- Audit table populated
- Summary generated in expected format
  </verify>
  <done>
Integration test passes, demonstrating that conflict resolver correctly uses sync-origin utilities, logs to audit table, and generates email-compatible summaries.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema verification:
   ```bash
   node -e "const db = require('./lib/stadion-db'); const d = db.openDb(':memory:'); const tables = d.prepare(\"SELECT name FROM sqlite_master WHERE type='table'\").all().map(t => t.name); console.log('Has conflict_resolutions:', tables.includes('conflict_resolutions'))"
   ```
   Expected: `Has conflict_resolutions: true`

2. Module exports verification:
   ```bash
   node -e "const cr = require('./lib/conflict-resolver'); console.log('resolveFieldConflicts:', typeof cr.resolveFieldConflicts); console.log('generateConflictSummary:', typeof cr.generateConflictSummary)"
   ```
   Expected: Both should be `function`

3. Database exports verification:
   ```bash
   node -e "const db = require('./lib/stadion-db'); console.log('logConflictResolution:', typeof db.logConflictResolution); console.log('getConflictResolutions:', typeof db.getConflictResolutions); console.log('getConflictResolutionCount:', typeof db.getConflictResolutionCount)"
   ```
   Expected: All three should be `function`

4. Self-test:
   ```bash
   node lib/conflict-resolver.js --test
   ```
   Expected: All tests pass
</verification>

<success_criteria>
Phase 21 is complete when:
1. conflict_resolutions audit table exists in stadion-sync.sqlite schema
2. lib/conflict-resolver.js exports resolveFieldConflicts and generateConflictSummary
3. lib/stadion-db.js exports logConflictResolution, getConflictResolutions, getConflictResolutionCount
4. Conflict detection uses 5-second grace period (Sportlink wins on near-ties)
5. NULL timestamps handled correctly (system with history wins)
6. Self-test passes demonstrating all behaviors
7. Summary format compatible with existing email infrastructure
</success_criteria>

<output>
After completion, create `.planning/phases/21-conflict-resolution-infrastructure/21-01-SUMMARY.md`
</output>
