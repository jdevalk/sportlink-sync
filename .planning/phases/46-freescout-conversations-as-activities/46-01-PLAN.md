---
phase: 46-freescout-conversations-as-activities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/freescout-conversations-db.js
  - steps/download-freescout-conversations.js
  - steps/prepare-freescout-activities.js
autonomous: true

must_haves:
  truths:
    - "FreeScout conversations are downloaded per customer with pagination handling for 50+ conversations"
    - "Incremental sync fetches only new conversations since last sync timestamp"
    - "Conversations are tracked in SQLite with UNIQUE constraint on conversation_id to prevent duplicates"
    - "Conversations are transformed into Rondo Club activity payloads with correct format"
  artifacts:
    - path: "lib/freescout-conversations-db.js"
      provides: "SQLite deduplication tracking for FreeScout conversations"
      exports: ["openDb", "getCustomersWithFreescoutId", "getUnsyncedConversations", "upsertConversations", "markConversationSynced", "getLastSyncTimestamp", "updateLastSyncTimestamp"]
    - path: "steps/download-freescout-conversations.js"
      provides: "Download conversations from FreeScout API with pagination and incremental sync"
      exports: ["runDownloadConversations"]
    - path: "steps/prepare-freescout-activities.js"
      provides: "Transform FreeScout conversations into Rondo Club activity payloads"
      exports: ["runPrepareActivities"]
  key_links:
    - from: "steps/download-freescout-conversations.js"
      to: "lib/freescout-client.js"
      via: "freescoutRequestWithRetry for API calls"
      pattern: "freescoutRequestWithRetry.*conversations"
    - from: "steps/download-freescout-conversations.js"
      to: "lib/freescout-conversations-db.js"
      via: "upsertConversations to persist downloaded data"
      pattern: "upsertConversations"
    - from: "steps/download-freescout-conversations.js"
      to: "lib/freescout-db.js"
      via: "getAllTrackedCustomers to get freescout_id → knvb_id mapping"
      pattern: "getAllTrackedCustomers|getCustomer"
    - from: "steps/prepare-freescout-activities.js"
      to: "lib/freescout-conversations-db.js"
      via: "getUnsyncedConversations for conversations needing activity creation"
      pattern: "getUnsyncedConversations"
---

<objective>
Create the FreeScout conversations database tracking module, download step with pagination and incremental sync, and prepare step that transforms conversations into Rondo Club activity payloads.

Purpose: Foundation for syncing FreeScout email conversations to Rondo Club person timelines — handles data acquisition and transformation.
Output: Three files: SQLite DB module, download step, prepare step. All follow existing project patterns.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-freescout-conversations-as-activities/46-RESEARCH.md

@lib/freescout-db.js — Pattern for SQLite tracking module (schema, upsert, hash-based change detection)
@lib/freescout-client.js — FreeScout API client with retry logic
@lib/rondo-club-db.js — Pattern for rondo_club_members table queries (knvb_id → rondo_club_id mapping)
@steps/download-nikki-contributions.js — Pattern for download step (module/CLI hybrid, logger, error handling)
@pipelines/sync-nikki.js — Pattern for pipeline orchestrator structure
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FreeScout conversations SQLite tracking module</name>
  <files>lib/freescout-conversations-db.js</files>
  <action>
Create `lib/freescout-conversations-db.js` following the exact pattern from `lib/freescout-db.js`:

**Database location:** `data/freescout-conversations.sqlite` (separate from freescout-sync.sqlite — different concern)

**Schema — `freescout_conversations` table:**
```sql
CREATE TABLE IF NOT EXISTS freescout_conversations (
  id INTEGER PRIMARY KEY,
  conversation_id INTEGER NOT NULL UNIQUE,
  knvb_id TEXT NOT NULL,
  freescout_customer_id INTEGER NOT NULL,
  subject TEXT,
  status TEXT,
  created_at TEXT NOT NULL,
  source_hash TEXT NOT NULL,
  rondo_club_activity_id INTEGER,
  last_synced_at TEXT
);
CREATE INDEX IF NOT EXISTS idx_conversations_knvb_id ON freescout_conversations (knvb_id);
CREATE INDEX IF NOT EXISTS idx_conversations_unsynced ON freescout_conversations (rondo_club_activity_id) WHERE rondo_club_activity_id IS NULL;
```

**Schema — `sync_metadata` table** (for incremental sync timestamp tracking):
```sql
CREATE TABLE IF NOT EXISTS sync_metadata (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);
```

**Exported functions (all follow freescout-db.js patterns):**

1. `openDb(dbPath)` — Open DB with WAL mode, busy_timeout, call initDb. Default path: `data/freescout-conversations.sqlite`
2. `upsertConversations(db, conversations)` — Bulk insert/update. Each conversation: `{ conversation_id, knvb_id, freescout_customer_id, subject, status, created_at, source_hash }`. Use `ON CONFLICT(conversation_id) DO UPDATE SET` for subject, status, source_hash, last_seen_at fields. Run in transaction.
3. `getUnsyncedConversations(db)` — Return conversations where `rondo_club_activity_id IS NULL`, ordered by `created_at ASC`. Join nothing — flat query. Return `{ conversation_id, knvb_id, freescout_customer_id, subject, status, created_at }`.
4. `markConversationSynced(db, conversationId, rondoClubActivityId)` — Update `rondo_club_activity_id` and `last_synced_at` for a given `conversation_id`.
5. `getLastSyncTimestamp(db)` — Read `value` from `sync_metadata` WHERE `key = 'last_download_at'`. Return null if not found.
6. `updateLastSyncTimestamp(db, timestamp)` — Upsert into `sync_metadata` with key `'last_download_at'`.
7. `computeConversationHash(conversation)` — Use `stableStringify` + `computeHash` from `../lib/utils` on `{ id, subject, status, createdAt }`.

Use `require('better-sqlite3')`, `require('path')`, and `require('./utils')` for stableStringify/computeHash. Follow module.exports pattern from freescout-db.js.
  </action>
  <verify>
Run: `node -e "const db = require('./lib/freescout-conversations-db'); const d = db.openDb(':memory:'); console.log('DB opened'); db.upsertConversations(d, [{ conversation_id: 1, knvb_id: 'TEST123', freescout_customer_id: 100, subject: 'Test', status: 'active', created_at: '2026-01-01T00:00:00Z', source_hash: 'abc' }]); const unsynced = db.getUnsyncedConversations(d); console.log('Unsynced:', unsynced.length); db.markConversationSynced(d, 1, 999); const after = db.getUnsyncedConversations(d); console.log('After sync:', after.length); console.log('OK');"` — should print DB opened, Unsynced: 1, After sync: 0, OK
  </verify>
  <done>SQLite module creates tables, upserts conversations, queries unsynced conversations, marks synced, and tracks last sync timestamp. All functions tested inline.</done>
</task>

<task type="auto">
  <name>Task 2: Create download and prepare steps for FreeScout conversations</name>
  <files>steps/download-freescout-conversations.js, steps/prepare-freescout-activities.js</files>
  <action>
**File 1: `steps/download-freescout-conversations.js`**

Follow the module/CLI hybrid pattern from `steps/download-nikki-contributions.js`.

**Core logic of `runDownloadConversations({ logger, verbose, force })`:**

1. Open freescout-conversations DB via `require('../lib/freescout-conversations-db').openDb()`
2. Open freescout-sync DB via `require('../lib/freescout-db').openDb()` to get customer list
3. Get all tracked customers with `freescout_id` from freescout-sync DB: `getAllTrackedCustomers(freescoutDb).filter(c => c.freescout_id)`
4. Get last sync timestamp from conversations DB (skip if `force=true`)
5. For each customer with a freescout_id:
   a. Fetch conversations from FreeScout API: `GET /api/conversations?customerId={freescout_id}` (add `&createdSince={lastSyncTimestamp}` for incremental sync if timestamp exists and not force)
   b. Handle pagination: check `response.body.page.totalPages`, loop through all pages. Use `page` query parameter (start at 1).
   c. For each conversation in response: compute hash via `computeConversationHash`, build record `{ conversation_id: conv.id, knvb_id: customer.knvb_id, freescout_customer_id: customer.freescout_id, subject: conv.subject || '', status: conv.status || '', created_at: conv.createdAt, source_hash: hash }`
   d. Add 100ms delay between customer requests (rate limiting precaution): `await new Promise(r => setTimeout(r, 100))`
6. Bulk upsert all conversations into conversations DB via `upsertConversations()`
7. Update last sync timestamp to current time via `updateLastSyncTimestamp()`
8. Close both DBs
9. Return `{ success: true, totalCustomers, totalConversations, newConversations }`

Use `freescoutRequestWithRetry` from `../lib/freescout-client` for all API calls. Use `createSyncLogger` from `../lib/logger`. Log progress every 50 customers: `logger.verbose(\`Processed ${i}/${total} customers...\`)`.

**Error handling:** Wrap each customer's fetch in try/catch — log error and continue to next customer. Don't fail the whole step for one customer's error.

**CLI entry point:**
```javascript
if (require.main === module) {
  const { verbose, force } = parseCliArgs();
  runDownloadConversations({ verbose, force })
    .then(result => { if (!result.success) process.exitCode = 1; })
    .catch(err => { console.error('Error:', err.message); process.exitCode = 1; });
}
```

**File 2: `steps/prepare-freescout-activities.js`**

**Core logic of `runPrepareActivities({ logger, verbose })`:**

1. Open freescout-conversations DB
2. Open rondo-sync DB via `require('../lib/rondo-club-db').openDb()` for knvb_id → rondo_club_id mapping
3. Get unsynced conversations via `getUnsyncedConversations(conversationsDb)`
4. For each unsynced conversation:
   a. Look up `rondo_club_id` from rondo-sync DB: `SELECT rondo_club_id FROM rondo_club_members WHERE knvb_id = ?`
   b. If no `rondo_club_id`, skip (log verbose, increment `skipped` counter)
   c. Build activity payload:
      ```javascript
      {
        personId: member.rondo_club_id,  // for URL path, not in body
        conversationId: conv.conversation_id,  // for tracking
        body: {
          content: `<p><strong>${escapeHtml(conv.subject)}</strong></p><p><a href="${freescoutUrl}/conversation/${conv.conversation_id}">Bekijk in FreeScout</a></p>`,
          activity_type: 'email',
          activity_date: conv.created_at.split('T')[0],  // YYYY-MM-DD
          activity_time: conv.created_at.split('T')[1]?.substring(0, 5) || ''  // HH:MM
        }
      }
      ```
   d. Read `FREESCOUT_BASE_URL` from env for the FreeScout link URL
5. Close both DBs
6. Return `{ success: true, total: unsynced.length, prepared: activities.length, skipped }`

**HTML escaping helper** (inline, simple):
```javascript
function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}
```

**CLI entry point:** Same pattern as download step.

Both files: `module.exports = { runDownloadConversations }` / `module.exports = { runPrepareActivities }` at bottom, then CLI entry point.
  </action>
  <verify>
Run: `node -e "require('./steps/download-freescout-conversations')"` — should load without error (module structure valid).
Run: `node -e "require('./steps/prepare-freescout-activities')"` — should load without error.
  </verify>
  <done>Download step fetches FreeScout conversations per customer with pagination and incremental sync support. Prepare step transforms unsynced conversations into Rondo Club activity payloads with person ID mapping. Both follow module/CLI hybrid pattern.</done>
</task>

</tasks>

<verification>
1. `node -e "require('./lib/freescout-conversations-db')"` loads without error
2. `node -e "require('./steps/download-freescout-conversations')"` loads without error
3. `node -e "require('./steps/prepare-freescout-activities')"` loads without error
4. In-memory DB test: open → upsert → query unsynced → mark synced → verify empty
5. All three files follow the module/CLI hybrid pattern (export functions + `if require.main === module`)
</verification>

<success_criteria>
- freescout-conversations-db.js creates proper SQLite schema with UNIQUE constraint on conversation_id
- Download step handles pagination (loops through all pages when totalPages > 1)
- Download step supports incremental sync via createdSince parameter
- Prepare step maps knvb_id to rondo_club_id and builds correct activity payload
- Prepare step skips conversations where rondo_club_id is not found
- All files load without errors
</success_criteria>

<output>
After completion, create `.planning/phases/46-freescout-conversations-as-activities/46-01-SUMMARY.md`
</output>
