---
phase: 35-run-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/run-tracker.js
  - pipelines/sync-people.js
  - pipelines/sync-nikki.js
  - pipelines/sync-teams.js
  - pipelines/sync-functions.js
  - pipelines/sync-discipline.js
  - pipelines/sync-freescout.js
  - pipelines/sync-all.js
autonomous: true

must_haves:
  truths:
    - "After any pipeline runs, dashboard.sqlite contains a row in runs with start time, end time, duration_ms, and outcome"
    - "Each run has per-step rows in run_steps with created/updated/skipped/failed counts"
    - "Individual sync errors are stored in run_errors with member identifier, step name, error message, and timestamp"
    - "All 6 pipelines write run data without modifying their core sync logic"
    - "Run tracking is a thin wrapper that adds 5-15 lines per pipeline"
    - "If the run tracker itself fails, the pipeline still completes normally"
  artifacts:
    - path: "lib/run-tracker.js"
      provides: "RunTracker class with startRun, startStep, endStep, recordError, endRun methods"
      exports: ["RunTracker"]
      min_lines: 100
    - path: "pipelines/sync-people.js"
      provides: "People pipeline instrumented with run tracking"
      contains: "RunTracker"
    - path: "pipelines/sync-nikki.js"
      provides: "Nikki pipeline instrumented with run tracking"
      contains: "RunTracker"
    - path: "pipelines/sync-teams.js"
      provides: "Teams pipeline instrumented with run tracking"
      contains: "RunTracker"
    - path: "pipelines/sync-functions.js"
      provides: "Functions pipeline instrumented with run tracking"
      contains: "RunTracker"
    - path: "pipelines/sync-discipline.js"
      provides: "Discipline pipeline instrumented with run tracking"
      contains: "RunTracker"
    - path: "pipelines/sync-freescout.js"
      provides: "FreeScout pipeline instrumented with run tracking"
      contains: "RunTracker"
    - path: "pipelines/sync-all.js"
      provides: "Sync-all pipeline instrumented with run tracking"
      contains: "RunTracker"
  key_links:
    - from: "lib/run-tracker.js"
      to: "lib/dashboard-db.js"
      via: "openDb() to get database connection"
      pattern: "require.*dashboard-db"
    - from: "pipelines/sync-*.js"
      to: "lib/run-tracker.js"
      via: "new RunTracker(pipeline) in each pipeline"
      pattern: "new RunTracker"
    - from: "lib/run-tracker.js"
      to: "data/dashboard.sqlite"
      via: "INSERT INTO runs/run_steps/run_errors"
      pattern: "INSERT INTO"
---

<objective>
Create a run-tracker library and instrument all 6 pipelines (plus sync-all) to persist structured run data to the dashboard database.

Purpose: Every pipeline run produces queryable data (run timing, per-step counts, individual errors) that the web dashboard (Phase 37) will display. Without this, there is nothing to show.

Output: `lib/run-tracker.js` with RunTracker class, and all 7 pipeline files modified to use it.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/34-infrastructure-foundation/34-01-SUMMARY.md
@lib/dashboard-db.js
@lib/utils.js
@pipelines/sync-people.js
@pipelines/sync-nikki.js
@pipelines/sync-teams.js
@pipelines/sync-functions.js
@pipelines/sync-discipline.js
@pipelines/sync-freescout.js
@pipelines/sync-all.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/run-tracker.js with RunTracker class</name>
  <files>lib/run-tracker.js</files>
  <action>
Create `lib/run-tracker.js` as a CommonJS module following existing codebase conventions (2-space indentation, JSDoc comments, module/CLI hybrid pattern).

The module exports a `RunTracker` class with the following API:

**Constructor: `new RunTracker(pipeline)`**
- `pipeline` (string): Pipeline name (e.g., 'people', 'nikki', 'teams', 'functions', 'discipline', 'freescout', 'all')
- Opens the dashboard database via `require('./dashboard-db').openDb()`
- Prepares all SQL statements (prepared statements for performance)
- Sets `this.runId = null` and `this.db = db`

**CRITICAL: All public methods must be wrapped in try/catch internally.** If tracking fails (e.g., database locked, disk full), it must log a warning to stderr but NOT throw. The pipeline must never crash because of tracking. Use a helper: `_safe(fn)` that wraps any function call in try/catch and logs errors to `console.error`.

**Method: `startRun()`**
- Inserts a row into `runs` with:
  - `pipeline`: the pipeline name from constructor
  - `started_at`: `nowISO()` from `lib/utils`
  - `outcome`: `'running'`
- Stores `this.runId = result.lastInsertRowid`
- Returns `this.runId` (or null if tracking failed)

**Method: `startStep(stepName)`**
- Inserts a row into `run_steps` with:
  - `run_id`: `this.runId`
  - `step_name`: stepName
  - `started_at`: `nowISO()`
- Returns `stepId` (lastInsertRowid) or null

**Method: `endStep(stepId, { outcome, created, updated, skipped, failed, detail })`**
- Updates the `run_steps` row with:
  - `finished_at`: `nowISO()`
  - `duration_ms`: computed from started_at to now (read started_at from the row, compute difference)
  - `outcome`: 'success' or 'failure' (default to 'success' if not specified)
  - `created_count`: created || 0
  - `updated_count`: updated || 0
  - `skipped_count`: skipped || 0
  - `failed_count`: failed || 0
  - `detail_json`: JSON.stringify(detail) if provided, else null
- For duration_ms: read the step's `started_at`, parse it, compute `new Date(nowISO()) - new Date(started_at)`

**Method: `recordError({ stepName, stepId, memberIdentifier, errorMessage, errorStack })`**
- Inserts a row into `run_errors` with:
  - `run_id`: this.runId
  - `run_step_id`: stepId || null
  - `step_name`: stepName
  - `member_identifier`: memberIdentifier || null
  - `error_message`: errorMessage (truncate to 2000 chars if longer)
  - `error_stack`: errorStack || null (truncate to 4000 chars if longer)
  - `created_at`: nowISO()

**Method: `recordErrors(stepName, stepId, errors)`**
- Convenience method for recording multiple errors from a pipeline step
- `errors` is an array of objects. Each may have:
  - `.knvb_id` or `.email` or `.dossier_id` or `.team_name` or `.commissie_name` -> used as memberIdentifier
  - `.message` or `.error` -> used as errorMessage
  - `.stack` -> used as errorStack
- For each error, calls `recordError()` with the mapped fields
- Also accepts a number (like nikki's `stats.rondoClub.errors` which is a number, not an array) -- if `errors` is a number, record a single error with message "Step reported N error(s)" only if > 0

**Method: `endRun(success, stats)`**
- `success`: boolean
- `stats`: the pipeline's raw stats object (stored as summary_json)
- Reads the run's `started_at` to compute `duration_ms`
- Computes totals by aggregating from `run_steps` for this run_id using a SUM query:
  ```sql
  SELECT
    COALESCE(SUM(created_count), 0) as total_created,
    COALESCE(SUM(updated_count), 0) as total_updated,
    COALESCE(SUM(skipped_count), 0) as total_skipped,
    COALESCE(SUM(failed_count), 0) as total_failed
  FROM run_steps WHERE run_id = ?
  ```
- Updates the `runs` row with:
  - `finished_at`: nowISO()
  - `duration_ms`: computed
  - `outcome`: success ? 'success' : 'failure'
  - `total_created`, `total_updated`, `total_skipped`, `total_failed`: from aggregate
  - `summary_json`: JSON.stringify(stats)
- Closes the database connection: `this.db.close()`

**Method: `close()`**
- Safety net: closes db if still open (idempotent)
- Called if pipeline exits without endRun (crash path)

**Prepared statements** (created in constructor):
```javascript
this._insertRun = db.prepare(`INSERT INTO runs (pipeline, started_at, outcome) VALUES (?, ?, 'running')`);
this._insertStep = db.prepare(`INSERT INTO run_steps (run_id, step_name, started_at) VALUES (?, ?, ?)`);
this._updateStep = db.prepare(`UPDATE run_steps SET finished_at = ?, duration_ms = ?, outcome = ?, created_count = ?, updated_count = ?, skipped_count = ?, failed_count = ?, detail_json = ? WHERE id = ?`);
this._insertError = db.prepare(`INSERT INTO run_errors (run_id, run_step_id, step_name, member_identifier, error_message, error_stack, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)`);
this._getStepStart = db.prepare(`SELECT started_at FROM run_steps WHERE id = ?`);
this._getRunStart = db.prepare(`SELECT started_at FROM runs WHERE id = ?`);
this._sumSteps = db.prepare(`SELECT COALESCE(SUM(created_count),0) as total_created, COALESCE(SUM(updated_count),0) as total_updated, COALESCE(SUM(skipped_count),0) as total_skipped, COALESCE(SUM(failed_count),0) as total_failed FROM run_steps WHERE run_id = ?`);
this._updateRun = db.prepare(`UPDATE runs SET finished_at = ?, duration_ms = ?, outcome = ?, total_created = ?, total_updated = ?, total_skipped = ?, total_failed = ?, summary_json = ? WHERE id = ?`);
```

**CLI block** (if require.main === module):
- Opens tracker for pipeline 'test'
- Calls startRun, startStep, endStep, recordError, endRun with sample data
- Prints "Run tracker test complete, run_id: {id}"
- Useful for verifying the module works in isolation

**Important design decisions:**
- Do NOT import `varlock/auto-load` -- this is a library, not a pipeline entry point
- The db is opened per-tracker instance and closed on endRun(). This avoids keeping a long-lived connection.
- All `_safe()` wrapped methods catch errors and log `[run-tracker] Error in {method}: {message}` to stderr
- If `this.runId` is null (startRun failed), all subsequent methods silently no-op
  </action>
  <verify>
Run `node lib/run-tracker.js` -- should print "Run tracker test complete, run_id: 1" without errors.

Verify the run was recorded:
```bash
node -e "
  const db = require('./lib/dashboard-db').openDb();
  const run = db.prepare('SELECT * FROM runs WHERE id = 1').get();
  console.log('Run:', JSON.stringify(run, null, 2));
  const steps = db.prepare('SELECT * FROM run_steps WHERE run_id = 1').all();
  console.log('Steps:', steps.length);
  const errors = db.prepare('SELECT * FROM run_errors WHERE run_id = 1').all();
  console.log('Errors:', errors.length);
  db.close();
"
```
Should show a run with outcome 'success' or 'failure', at least 1 step, and at least 1 error.
  </verify>
  <done>
`lib/run-tracker.js` exists and exports `RunTracker` class. The class provides startRun, startStep, endStep, recordError, recordErrors, endRun, and close methods. All methods are wrapped in try/catch so tracking failures never crash pipelines. CLI self-test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument all 7 pipeline files with run tracking</name>
  <files>
    pipelines/sync-people.js
    pipelines/sync-nikki.js
    pipelines/sync-teams.js
    pipelines/sync-functions.js
    pipelines/sync-discipline.js
    pipelines/sync-freescout.js
    pipelines/sync-all.js
  </files>
  <action>
Add run tracking to each of the 7 pipeline files. The pattern is the same for each pipeline, with pipeline-specific step names and error mappings. The goal is MINIMAL changes -- approximately 5-15 lines added per pipeline.

**Pattern for each pipeline:**

1. Add require at top of file:
```javascript
const { RunTracker } = require('../lib/run-tracker');
```

2. After `const startTime = Date.now();` (or equivalent), add:
```javascript
const tracker = new RunTracker('PIPELINE_NAME');
tracker.startRun();
```

3. Around each step's try/catch block, add `startStep` before and `endStep` + `recordErrors` after. The tracking calls go INSIDE the existing try/catch for each step, not replacing them. The pattern is:

```javascript
// Before the step
const stepId = tracker.startStep('step-name');

// ... existing step code ...

// After the step succeeds (inside try, after stats are collected)
tracker.endStep(stepId, {
  outcome: 'success',
  created: stats.xxx.created,
  updated: stats.xxx.updated,
  skipped: stats.xxx.skipped,
  failed: stats.xxx.errors.length
});
tracker.recordErrors('step-name', stepId, stats.xxx.errors);

// In the catch block, add:
tracker.endStep(stepId, { outcome: 'failure' });
tracker.recordError({
  stepName: 'step-name',
  stepId,
  errorMessage: err.message,
  errorStack: err.stack
});
```

4. Before the final `return { success, stats }`, add:
```javascript
tracker.endRun(success_expression, stats);
```
Where `success_expression` matches the existing success computation in each pipeline.

5. In the outer catch block (fatal error), add:
```javascript
tracker.endRun(false, stats);
```

6. For early returns (e.g., sync-people.js returns early if download fails), add `tracker.endRun(false, stats)` before the return.

**Pipeline-specific instrumentation:**

**sync-people.js** (pipeline: 'people', 7 steps):
- Step 'sportlink-download': after downloadResult, endStep with created=stats.downloaded
- Step 'laposta-prepare': after prepareResult, endStep with created=stats.prepared
- Step 'laposta-submit': after submitResult, endStep with created=stats.added, updated=stats.updated, failed=stats.errors.length
- Step 'rondo-club-sync': endStep with created=stats.rondoClub.created, updated=stats.rondoClub.updated, skipped=stats.rondoClub.skipped, failed=stats.rondoClub.errors.length
- Step 'photo-download': endStep with created=stats.photos.downloaded, failed=stats.photos.errors.length
- Step 'photo-upload': endStep with created=stats.photos.uploaded, skipped=stats.photos.skipped, failed=stats.photos.errors.length
- Step 'reverse-sync': endStep with updated=stats.reverseSync.synced, failed=stats.reverseSync.errors.length
- recordErrors for each step using the respective error arrays
- Early return paths (download fail at line ~158, prepare fail at line ~174): add tracker.endRun(false, stats) before return

**sync-nikki.js** (pipeline: 'nikki', 2 steps):
- Step 'nikki-download': endStep with created=stats.download.count, failed=stats.download.errors.length
- Step 'rondo-club-sync': endStep with updated=stats.rondoClub.updated, skipped=stats.rondoClub.skipped
  - NOTE: `stats.rondoClub.errors` is a NUMBER, not an array. Use `recordErrors` which handles numbers.
  - For the failed count in endStep, use: `typeof stats.rondoClub.errors === 'number' ? stats.rondoClub.errors : 0`

**sync-teams.js** (pipeline: 'teams', 3 steps):
- Step 'team-download': endStep with created=stats.download.teamCount
- Step 'team-sync': endStep with created=stats.teams.created, updated=stats.teams.updated, skipped=stats.teams.skipped, failed=stats.teams.errors.length
- Step 'work-history-sync': endStep with created=stats.workHistory.created, updated=stats.workHistory.ended, skipped=stats.workHistory.skipped, failed=stats.workHistory.errors.length

**sync-functions.js** (pipeline: 'functions', 3 steps):
- Step 'functions-download': endStep with created=stats.download.total, failed=stats.download.errors.length
- Step 'commissie-sync': endStep with created=stats.commissies.created, updated=stats.commissies.updated, skipped=stats.commissies.skipped, failed=stats.commissies.errors.length
- Step 'commissie-work-history-sync': endStep with created=stats.workHistory.created, updated=stats.workHistory.ended, skipped=stats.workHistory.skipped, failed=stats.workHistory.errors.length

**sync-discipline.js** (pipeline: 'discipline', 2 steps):
- Step 'discipline-download': endStep with created=stats.download.caseCount
- Step 'discipline-sync': endStep with created=stats.sync.created, updated=stats.sync.updated, skipped=stats.sync.skipped, failed=stats.sync.errors.length

**sync-freescout.js** (pipeline: 'freescout', 1 step):
- Step 'freescout-sync': endStep with created=stats.created, updated=stats.updated, skipped=stats.skipped, failed=stats.errors.length
- NOTE: Early return path if credentials not configured: add tracker.endRun(false, stats) before that return

**sync-all.js** (pipeline: 'all', 12+ steps):
- This pipeline calls steps directly, not via the individual pipeline modules (except discipline which it delegates to sync-discipline.js)
- Instrument it with the same pattern: one tracker for the whole 'all' pipeline
- Steps (use names matching the sync-all code):
  - 'sportlink-download', 'laposta-prepare', 'laposta-submit'
  - 'rondo-club-sync', 'team-download', 'team-sync', 'work-history-sync'
  - 'functions-download', 'commissie-sync', 'commissie-work-history-sync'
  - 'photo-download', 'photo-upload'
  - 'freescout-sync', 'discipline-sync'
- For discipline, sync-all calls `runDisciplinePipelineSync()` which will create its OWN tracker run (since we instrumented sync-discipline.js above). That is fine -- the 'all' pipeline gets a step row for 'discipline-sync', and the discipline pipeline also gets its own separate run. This is correct behavior (the 'all' run tracks the overall pipeline, the discipline run tracks that specific pipeline).
- The sync-all early return paths (download fail, prepare fail) need tracker.endRun(false, stats)

**CRITICAL CONSTRAINTS:**
- Do NOT change the structure of the stats objects
- Do NOT change the success/failure logic
- Do NOT change the printSummary calls
- Do NOT change what the pipeline returns
- Do NOT move any existing code around -- only ADD tracker lines
- Each tracker call is a single line. Keep it minimal.
- The tracker is created early and closed late (on endRun). If the pipeline crashes between creation and endRun, the `close()` method is available but since the database connection is lightweight and Node will clean up on exit, this is acceptable.
  </action>
  <verify>
For each pipeline, verify tracking was added correctly by checking the require and RunTracker usage:

```bash
node -e "
  const files = [
    'pipelines/sync-people.js',
    'pipelines/sync-nikki.js',
    'pipelines/sync-teams.js',
    'pipelines/sync-functions.js',
    'pipelines/sync-discipline.js',
    'pipelines/sync-freescout.js',
    'pipelines/sync-all.js'
  ];
  for (const f of files) {
    const src = require('fs').readFileSync(f, 'utf-8');
    const hasRequire = src.includes('RunTracker');
    const hasStartRun = src.includes('tracker.startRun()');
    const hasEndRun = src.includes('tracker.endRun(');
    const hasStartStep = src.includes('tracker.startStep(');
    console.log(f + ': require=' + hasRequire + ' startRun=' + hasStartRun + ' endRun=' + hasEndRun + ' startStep=' + hasStartStep);
  }
"
```

All should print `true` for all 4 checks.

Then verify the module loads without syntax errors:
```bash
node -e "require('./pipelines/sync-people')" 2>&1 | head -5
node -e "require('./pipelines/sync-nikki')" 2>&1 | head -5
node -e "require('./pipelines/sync-teams')" 2>&1 | head -5
node -e "require('./pipelines/sync-functions')" 2>&1 | head -5
node -e "require('./pipelines/sync-discipline')" 2>&1 | head -5
node -e "require('./pipelines/sync-freescout')" 2>&1 | head -5
node -e "require('./pipelines/sync-all')" 2>&1 | head -5
```

Each should complete without errors (may print warnings about missing env vars -- that is fine). No "SyntaxError" or "ReferenceError" output.
  </verify>
  <done>
All 7 pipeline files (sync-people, sync-nikki, sync-teams, sync-functions, sync-discipline, sync-freescout, sync-all) import RunTracker and call startRun/startStep/endStep/recordErrors/endRun. Each pipeline's core logic is unchanged. After any pipeline runs on the server, `dashboard.sqlite` will contain rows in `runs`, `run_steps`, and `run_errors` tables.
  </done>
</task>

</tasks>

<verification>
1. `lib/run-tracker.js` exists, exports `RunTracker`, and its CLI self-test passes: `node lib/run-tracker.js`
2. All 7 pipeline files import `RunTracker` and call `startRun()`, `startStep()`, `endStep()`, `endRun()`
3. All 7 pipeline files load without syntax errors when required
4. The run-tracker's try/catch safety means a simulated tracking failure does not crash: `node -e "const {RunTracker} = require('./lib/run-tracker'); const t = new RunTracker('test'); t.db.close(); t.startRun(); console.log('Still running after tracker failure')"` -- should print the message without throwing
5. No changes to pipeline stats collection, success logic, printSummary, or return values
6. Requirements covered: TRACK-01 (run timing + outcome), TRACK-02 (per-step counts), TRACK-03 (error storage), TRACK-04 (all 6 pipelines), TRACK-05 (thin wrapper)
</verification>

<success_criteria>
- TRACK-01: `runs` table populated with pipeline, started_at, finished_at, duration_ms, outcome after any pipeline run
- TRACK-02: `run_steps` table populated with per-step created/updated/skipped/failed counts
- TRACK-03: `run_errors` table populated with member_identifier, step_name, error_message, created_at
- TRACK-04: All 6 named pipelines (people, nikki, teams, functions, discipline, freescout) plus sync-all are instrumented
- TRACK-05: Each pipeline file has ~5-15 added lines (require + tracker calls), no restructuring
- Run tracking failures do not crash pipelines (try/catch safety)
</success_criteria>

<output>
After completion, create `.planning/phases/35-run-tracking/35-01-SUMMARY.md`
</output>
