---
phase: 11-photo-upload-deletion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - upload-photos-to-stadion.js
autonomous: true

must_haves:
  truths:
    - "Photos with state 'downloaded' get uploaded to Stadion"
    - "Photos with state 'pending_delete' get deleted from local storage and Stadion"
    - "Member must have stadion_id before photo upload can proceed"
    - "Upload/delete failures are logged but don't stop batch processing"
  artifacts:
    - path: "upload-photos-to-stadion.js"
      provides: "Photo upload and deletion orchestration"
      exports: ["runPhotoSync"]
      min_lines: 150
  key_links:
    - from: "upload-photos-to-stadion.js"
      to: "lib/stadion-db.js"
      via: "getMembersByPhotoState, updatePhotoState, clearPhotoState"
      pattern: "getMembersByPhotoState.*downloaded|pending_delete"
    - from: "upload-photos-to-stadion.js"
      to: "Stadion API"
      via: "multipart/form-data POST to /stadion/v1/people/{id}/photo"
      pattern: "stadion/v1/people.*photo"
---

<objective>
Create photo sync script that uploads downloaded photos to Stadion and handles photo deletion when photos are removed in Sportlink.

Purpose: Complete the photo sync pipeline by syncing local photos to WordPress and cleaning up removed photos.
Output: `upload-photos-to-stadion.js` with runPhotoSync function handling both upload and delete operations.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-photo-upload-deletion/11-RESEARCH.md

# Key source files for patterns
@lib/stadion-db.js (getMembersByPhotoState, updatePhotoState, clearPhotoState)
@lib/stadion-client.js (stadionRequest pattern, auth headers)
@submit-stadion-sync.js (sequential processing, rate limiting, error handling patterns)
@download-photos-from-sportlink.js (MIME type mapping, file operations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Photo Upload Script</name>
  <files>upload-photos-to-stadion.js</files>
  <action>
Create `upload-photos-to-stadion.js` following the module/CLI hybrid pattern from existing scripts.

**Core function: `runPhotoSync(options)`**

The script handles two operations in sequence:
1. **Photo Upload** - Process members with photo_state = 'downloaded'
2. **Photo Deletion** - Process members with photo_state = 'pending_delete'

**Upload implementation:**

```javascript
// Use form-data for multipart upload (already installed)
const FormData = require('form-data');
const fs = require('fs');
const fsPromises = require('fs/promises');
const https = require('https');
const { URL } = require('url');
const path = require('path');

const PHOTO_EXTENSIONS = ['jpg', 'jpeg', 'png', 'webp', 'gif'];

// Find photo file by checking known extensions
async function findPhotoFile(knvbId) {
  const photosDir = path.join(process.cwd(), 'photos');
  for (const ext of PHOTO_EXTENSIONS) {
    const filepath = path.join(photosDir, `${knvbId}.${ext}`);
    try {
      await fsPromises.access(filepath, fs.constants.R_OK);
      return filepath;
    } catch {
      continue;
    }
  }
  throw new Error(`No photo file found for ${knvbId}`);
}

// Multipart upload to Stadion custom endpoint
function uploadPhotoToStadion(stadionId, photoPath, options) {
  return new Promise((resolve, reject) => {
    const form = new FormData();
    form.append('file', fs.createReadStream(photoPath));

    const baseUrl = process.env.STADION_URL;
    const authHeader = `Basic ${Buffer.from(
      `${process.env.STADION_USERNAME}:${process.env.STADION_APP_PASSWORD}`
    ).toString('base64')}`;

    const parsedUrl = new URL(baseUrl);
    const apiPath = `/wp-json/stadion/v1/people/${stadionId}/photo`;

    const request = https.request({
      hostname: parsedUrl.hostname,
      port: parsedUrl.port || 443,
      path: apiPath,
      method: 'POST',
      headers: {
        ...form.getHeaders(),
        'Authorization': authHeader
      },
      timeout: 30000
    }, (response) => {
      let data = '';
      response.on('data', chunk => data += chunk);
      response.on('end', () => {
        if (response.statusCode >= 200 && response.statusCode < 300) {
          resolve({ status: response.statusCode, body: data ? JSON.parse(data) : {} });
        } else {
          const error = new Error(`Upload failed: ${response.statusCode}`);
          error.status = response.statusCode;
          error.details = data;
          reject(error);
        }
      });
    });

    request.on('error', reject);
    request.on('timeout', () => {
      request.destroy();
      reject(new Error('Upload timeout'));
    });

    form.pipe(request);
  });
}
```

**Deletion implementation:**

```javascript
// Delete photo from Stadion via custom endpoint
async function deletePhotoFromStadion(stadionId, options) {
  const { stadionRequest } = require('./lib/stadion-client');
  return stadionRequest(`stadion/v1/people/${stadionId}/photo`, 'DELETE', null, options);
}

// Safe local file deletion
async function deleteLocalPhoto(knvbId, logger) {
  try {
    const photoPath = await findPhotoFile(knvbId);
    await fsPromises.unlink(photoPath);
    logger.verbose(`Deleted local photo: ${photoPath}`);
    return { success: true, deleted: photoPath };
  } catch (error) {
    if (error.code === 'ENOENT' || error.message.includes('No photo file found')) {
      logger.verbose(`Photo file not found for ${knvbId} - already deleted`);
      return { success: true, notFound: true };
    }
    throw error;
  }
}
```

**Main orchestration:**

```javascript
async function runPhotoSync(options = {}) {
  const { verbose = false, logger: providedLogger } = options;
  const logger = providedLogger || createSyncLogger({ verbose });

  const result = {
    success: true,
    upload: { total: 0, uploaded: 0, skipped: 0, errors: [] },
    delete: { total: 0, deleted: 0, errors: [] }
  };

  const db = openDb();
  try {
    // Phase 1: Upload downloaded photos
    const toUpload = getMembersByPhotoState(db, 'downloaded');
    result.upload.total = toUpload.length;

    for (let i = 0; i < toUpload.length; i++) {
      const member = toUpload[i];

      if (!member.stadion_id) {
        logger.error(`Member ${member.knvb_id} not synced to Stadion - cannot upload photo`);
        result.upload.skipped++;
        continue;
      }

      try {
        const photoPath = await findPhotoFile(member.knvb_id);
        await uploadPhotoToStadion(member.stadion_id, photoPath, options);
        updatePhotoState(db, member.knvb_id, 'synced');
        result.upload.uploaded++;
      } catch (error) {
        result.upload.errors.push({ knvb_id: member.knvb_id, message: error.message });
        logger.error(`Failed to upload ${member.knvb_id}: ${error.message}`);
      }

      if (i < toUpload.length - 1) {
        await new Promise(r => setTimeout(r, 2000)); // Rate limit
      }
    }

    // Phase 2: Delete removed photos
    const toDelete = getMembersByPhotoState(db, 'pending_delete');
    result.delete.total = toDelete.length;

    for (let i = 0; i < toDelete.length; i++) {
      const member = toDelete[i];

      try {
        // Delete local file first
        await deleteLocalPhoto(member.knvb_id, logger);

        // Delete from Stadion if member exists there
        if (member.stadion_id) {
          try {
            await deletePhotoFromStadion(member.stadion_id, options);
          } catch (error) {
            // Log but continue - local file is source of truth
            logger.verbose(`Stadion photo delete failed for ${member.knvb_id}: ${error.message}`);
          }
        }

        clearPhotoState(db, member.knvb_id);
        result.delete.deleted++;
      } catch (error) {
        result.delete.errors.push({ knvb_id: member.knvb_id, message: error.message });
        logger.error(`Failed to delete ${member.knvb_id}: ${error.message}`);
      }

      if (i < toDelete.length - 1) {
        await new Promise(r => setTimeout(r, 2000));
      }
    }

    // Summary
    logger.log(`Photo upload: ${result.upload.uploaded}/${result.upload.total}`);
    logger.log(`Photo delete: ${result.delete.deleted}/${result.delete.total}`);

    result.success = result.upload.errors.length === 0 && result.delete.errors.length === 0;
    return result;

  } finally {
    db.close();
  }
}
```

**CLI entry point:**

```javascript
module.exports = { runPhotoSync };

if (require.main === module) {
  const verbose = process.argv.includes('--verbose');
  runPhotoSync({ verbose })
    .then(result => {
      if (!result.success) process.exitCode = 1;
    })
    .catch(err => {
      console.error('Error:', err.message);
      process.exitCode = 1;
    });
}
```

**Key patterns to follow:**
- Use `require('varlock/auto-load')` at top for env loading
- Import from lib/stadion-db.js and lib/stadion-client.js
- Use createSyncLogger from lib/logger.js
- 2-second rate limiting between API calls (matches submit-stadion-sync.js)
- Log failures and continue - don't fail fast
- Return structured result object for pipeline integration
  </action>
  <verify>
Run `node upload-photos-to-stadion.js --verbose` (will report "0 photos pending upload/delete" if no pending photos, which is expected after initial setup).

Check syntax: `node -c upload-photos-to-stadion.js` should show no errors.

Verify module export: `node -e "const { runPhotoSync } = require('./upload-photos-to-stadion'); console.log(typeof runPhotoSync)"` should output "function".
  </verify>
  <done>
Script exists and exports runPhotoSync function. Handles both upload (downloaded -> synced) and delete (pending_delete -> no_photo) state transitions. Uses multipart/form-data for uploads, sequential processing with rate limiting, and graceful error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add npm script for photo sync</name>
  <files>package.json</files>
  <action>
Add npm script for running photo sync:

In package.json scripts section, add:
```json
"sync-photos": "node upload-photos-to-stadion.js",
"sync-photos-verbose": "node upload-photos-to-stadion.js --verbose"
```

This follows the existing pattern of having both standard and verbose versions of sync commands.
  </action>
  <verify>
Run `npm run sync-photos` - should execute without syntax errors and report photo sync status (likely "0 photos pending upload/delete" on fresh run).
  </verify>
  <done>
npm scripts added for `sync-photos` and `sync-photos-verbose`. Users can run `npm run sync-photos` to sync photos to Stadion.
  </done>
</task>

</tasks>

<verification>
1. `node -c upload-photos-to-stadion.js` - No syntax errors
2. `npm run sync-photos` - Executes and reports status
3. Module exports runPhotoSync function for pipeline integration
4. Script handles both upload and delete operations
5. Rate limiting (2s delays) matches existing patterns
6. Error handling logs failures but continues processing
</verification>

<success_criteria>
- upload-photos-to-stadion.js exists with runPhotoSync export
- Script processes 'downloaded' photos for upload to Stadion
- Script processes 'pending_delete' photos for local and Stadion deletion
- npm run sync-photos works
- Follows existing codebase patterns (module/CLI hybrid, rate limiting, error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/11-photo-upload-deletion/11-01-SUMMARY.md`
</output>
