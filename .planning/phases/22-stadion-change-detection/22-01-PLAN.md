---
phase: 22-stadion-change-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/stadion-db.js
  - lib/detect-stadion-changes.js
  - detect-stadion-changes.js
autonomous: true

must_haves:
  truths:
    - "System queries Stadion API for members modified since last detection"
    - "Hash comparison identifies actual field changes in tracked fields"
    - "Detected changes logged to SQLite audit table"
    - "Detection run timestamp tracked for incremental detection"
  artifacts:
    - path: "lib/detect-stadion-changes.js"
      provides: "Change detection logic module"
      exports: ["detectChanges", "extractFieldValue", "computeTrackedFieldsHash"]
    - path: "detect-stadion-changes.js"
      provides: "CLI entry point for change detection"
      min_lines: 30
    - path: "lib/stadion-db.js"
      provides: "Database schema additions"
      contains: "stadion_change_detections"
  key_links:
    - from: "lib/detect-stadion-changes.js"
      to: "lib/stadion-client.js"
      via: "stadionRequest for API queries"
      pattern: "stadionRequest.*modified_after"
    - from: "lib/detect-stadion-changes.js"
      to: "lib/sync-origin.js"
      via: "TRACKED_FIELDS constant"
      pattern: "TRACKED_FIELDS"
    - from: "lib/detect-stadion-changes.js"
      to: "lib/stadion-db.js"
      via: "database operations"
      pattern: "openDb|logChangeDetection"
---

<objective>
Create Stadion change detection script that identifies members with modifications newer than the last forward sync for reverse sync.

Purpose: This is Phase 22 of the bidirectional sync roadmap. It detects which Stadion members have field changes that need to flow back to Sportlink. This phase detects changes only - actual reverse sync happens in Phases 23-24.

Output: Change detection module with SQLite audit table, incremental timestamp tracking, and hash-based field comparison for the 7 tracked fields.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-foundation/20-01-SUMMARY.md
@.planning/phases/21-conflict-resolution-infrastructure/21-01-SUMMARY.md
@.planning/phases/22-stadion-change-detection/22-CONTEXT.md
@.planning/phases/22-stadion-change-detection/22-RESEARCH.md
@lib/stadion-db.js
@lib/stadion-client.js
@lib/sync-origin.js
@prepare-stadion-members.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database schema for change detection</name>
  <files>lib/stadion-db.js</files>
  <action>
Add two new tables to lib/stadion-db.js initDb() function:

1. `stadion_change_detections` audit table (similar to conflict_resolutions pattern):
```sql
CREATE TABLE IF NOT EXISTS stadion_change_detections (
  id INTEGER PRIMARY KEY,
  knvb_id TEXT NOT NULL,
  field_name TEXT NOT NULL,
  old_value TEXT,
  new_value TEXT,
  detected_at TEXT NOT NULL,
  stadion_modified_gmt TEXT NOT NULL,
  detection_run_id TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_stadion_change_detections_knvb
  ON stadion_change_detections (knvb_id);

CREATE INDEX IF NOT EXISTS idx_stadion_change_detections_detected
  ON stadion_change_detections (detected_at);
```

2. `reverse_sync_state` singleton table for tracking last detection run:
```sql
CREATE TABLE IF NOT EXISTS reverse_sync_state (
  id INTEGER PRIMARY KEY CHECK (id = 1),
  last_detection_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
);
```

3. Add migration to stadion_members for `tracked_fields_hash` column (if not exists):
```javascript
if (!memberColumns.some(col => col.name === 'tracked_fields_hash')) {
  db.exec('ALTER TABLE stadion_members ADD COLUMN tracked_fields_hash TEXT');
}
```

4. Add helper functions at the end of the file (before module.exports):
- `logChangeDetection(db, detection)` - insert into stadion_change_detections
- `getChangeDetections(db, since = null)` - get detections since timestamp
- `getLastDetectionTime(db)` - get last_detection_at from reverse_sync_state
- `updateLastDetectionTime(db, timestamp)` - upsert reverse_sync_state

5. Export the new functions in module.exports.
  </action>
  <verify>
Run: `node -e "const db = require('./lib/stadion-db'); const d = db.openDb(':memory:'); console.log('Tables created successfully'); const cols = d.prepare('PRAGMA table_info(stadion_members)').all(); console.log('tracked_fields_hash:', cols.some(c => c.name === 'tracked_fields_hash')); const tables = d.prepare(\"SELECT name FROM sqlite_master WHERE type='table'\").all().map(t => t.name); console.log('Has change_detections:', tables.includes('stadion_change_detections')); console.log('Has reverse_sync_state:', tables.includes('reverse_sync_state')); console.log('Exports:', Object.keys(db).filter(k => k.includes('Detection') || k.includes('LastDetection')))"`
Expected: Tables created, tracked_fields_hash column exists, helper functions exported
  </verify>
  <done>Database schema supports change detection with audit table, state tracking, and tracked_fields_hash column</done>
</task>

<task type="auto">
  <name>Task 2: Create change detection module</name>
  <files>lib/detect-stadion-changes.js, detect-stadion-changes.js</files>
  <action>
Create lib/detect-stadion-changes.js with the change detection logic:

1. Import required modules:
   - `stadionRequest` from ./stadion-client
   - `openDb`, `logChangeDetection`, `getLastDetectionTime`, `updateLastDetectionTime` from ./stadion-db
   - `TRACKED_FIELDS`, `SYNC_ORIGIN` from ./sync-origin
   - `createSyncLogger` from ./logger
   - `crypto` for hash computation

2. Implement `stableStringify(value)` - reuse pattern from stadion-db.js for deterministic JSON

3. Implement `computeTrackedFieldsHash(knvbId, stadionData)`:
   - Extract only TRACKED_FIELDS values
   - Use extractFieldValue() for each field
   - Return SHA-256 hash of stable JSON

4. Implement `extractFieldValue(stadionData, field)`:
   - For contact fields (email, email2, mobile, phone): extract from acf.contact_info repeater array
     - `email` maps to contact_type='email'
     - `email2` maps to contact_type='email2' (if exists) or second email entry
     - `mobile` maps to contact_type='mobile'
     - `phone` maps to contact_type='phone'
   - For direct fields (datum_vog, freescout_id, financiele_blokkade): extract from acf directly
     - Use acf['datum-vog'], acf['freescout-id'], acf['financiele-blokkade']

5. Implement `fetchModifiedMembers(since, options)`:
   - Paginate through Stadion API: `wp/v2/people?per_page=100&page=${page}&modified_after=${since}&_fields=id,modified_gmt,acf`
   - Follow existing pagination pattern from submit-stadion-teams.js
   - Return array of all modified members

6. Implement `async detectChanges(options = {})` main function:
   - Get lastDetection from getLastDetectionTime() or use '2020-01-01T00:00:00Z' for first run
   - Generate detectionRunId = new Date().toISOString()
   - Fetch modified members from Stadion API
   - For each member:
     a. Extract knvb_id from acf['knvb-id']
     b. Skip if not in local database
     c. Skip if sync_origin === SYNC_ORIGIN.SYNC_FORWARD (last change was from forward sync)
     d. Compute currentHash = computeTrackedFieldsHash()
     e. Compare against stored tracked_fields_hash
     f. If hash changed, compare each TRACKED_FIELD individually
     g. Log detected changes via logChangeDetection()
   - Update lastDetectionTime after successful run
   - Return array of detected changes

7. Export: `detectChanges`, `extractFieldValue`, `computeTrackedFieldsHash`

Create detect-stadion-changes.js CLI wrapper:
- Same module/CLI hybrid pattern as other scripts
- Parse --verbose flag
- Call detectChanges() and report results
- Exit code 0 on success, 1 on error
  </action>
  <verify>
Run: `node -e "const { extractFieldValue, computeTrackedFieldsHash } = require('./lib/detect-stadion-changes'); const mockData = { acf: { contact_info: [{ contact_type: 'email', contact_value: 'test@example.com' }], 'datum-vog': '2025-01-15', 'knvb-id': 'TEST123' } }; console.log('email:', extractFieldValue(mockData, 'email')); console.log('datum_vog:', extractFieldValue(mockData, 'datum_vog')); console.log('hash:', computeTrackedFieldsHash('TEST123', mockData).substring(0, 16) + '...')"`
Expected: email: test@example.com, datum_vog: 2025-01-15, hash: [64-char hex string prefix]...
  </verify>
  <done>Change detection module extracts field values from Stadion ACF structure and computes tracked fields hash</done>
</task>

<task type="auto">
  <name>Task 3: Verify integration and add self-test</name>
  <files>lib/detect-stadion-changes.js</files>
  <action>
Add a self-test block at the end of lib/detect-stadion-changes.js (similar to conflict-resolver.js pattern):

```javascript
// Self-test when run directly
if (require.main === module) {
  const { openDb } = require('./stadion-db');

  async function selfTest() {
    console.log('=== Stadion Change Detection Self-Test ===\n');

    // Test 1: Field extraction from contact_info
    console.log('Test 1: Field extraction from contact_info');
    const mockMember = {
      acf: {
        contact_info: [
          { contact_type: 'email', contact_value: 'john@example.com' },
          { contact_type: 'mobile', contact_value: '+31612345678' },
          { contact_type: 'phone', contact_value: '+31201234567' }
        ],
        'datum-vog': '2025-06-15',
        'freescout-id': 42,
        'financiele-blokkade': true
      }
    };

    const email = extractFieldValue(mockMember, 'email');
    const mobile = extractFieldValue(mockMember, 'mobile');
    const phone = extractFieldValue(mockMember, 'phone');
    const datumVog = extractFieldValue(mockMember, 'datum_vog');
    const freescoutId = extractFieldValue(mockMember, 'freescout_id');
    const financieleBlockkade = extractFieldValue(mockMember, 'financiele_blokkade');

    console.log(`  email: ${email} (expected: john@example.com)`);
    console.log(`  mobile: ${mobile} (expected: +31612345678)`);
    console.log(`  phone: ${phone} (expected: +31201234567)`);
    console.log(`  datum_vog: ${datumVog} (expected: 2025-06-15)`);
    console.log(`  freescout_id: ${freescoutId} (expected: 42)`);
    console.log(`  financiele_blokkade: ${financieleBlockkade} (expected: true)`);
    console.log('');

    // Test 2: Hash computation
    console.log('Test 2: Hash computation (deterministic)');
    const hash1 = computeTrackedFieldsHash('KNVB123', mockMember);
    const hash2 = computeTrackedFieldsHash('KNVB123', mockMember);
    console.log(`  hash1: ${hash1.substring(0, 32)}...`);
    console.log(`  hash2: ${hash2.substring(0, 32)}...`);
    console.log(`  identical: ${hash1 === hash2} (expected: true)`);
    console.log('');

    // Test 3: Database helpers
    console.log('Test 3: Database helper functions');
    const db = openDb(':memory:');

    // Test getLastDetectionTime (should be null initially)
    const { getLastDetectionTime, updateLastDetectionTime, logChangeDetection, getChangeDetections } = require('./stadion-db');
    const initial = getLastDetectionTime(db);
    console.log(`  initial lastDetection: ${initial} (expected: null)`);

    // Test updateLastDetectionTime
    const testTime = '2026-01-29T12:00:00.000Z';
    updateLastDetectionTime(db, testTime);
    const updated = getLastDetectionTime(db);
    console.log(`  after update: ${updated} (expected: ${testTime})`);

    // Test logChangeDetection
    logChangeDetection(db, {
      knvb_id: 'TEST123',
      field_name: 'email',
      old_value: 'old@test.com',
      new_value: 'new@test.com',
      stadion_modified_gmt: '2026-01-29T11:00:00.000Z',
      detection_run_id: testTime
    });

    const detections = getChangeDetections(db);
    console.log(`  logged detections: ${detections.length} (expected: 1)`);
    console.log(`  detection field: ${detections[0]?.field_name} (expected: email)`);

    db.close();
    console.log('\n=== All tests passed ===');
  }

  selfTest().catch(err => {
    console.error('Self-test failed:', err);
    process.exit(1);
  });
}
```

This verifies:
1. Field extraction works for all 7 tracked fields
2. Hash computation is deterministic
3. Database helpers work correctly (last detection time, change logging)
  </action>
  <verify>
Run: `node lib/detect-stadion-changes.js`
Expected output: All tests passed with correct values shown
  </verify>
  <done>Change detection module verified with self-test covering field extraction, hash computation, and database operations</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. Schema verification:
```bash
node -e "const db = require('./lib/stadion-db'); const d = db.openDb(':memory:'); const tables = d.prepare(\"SELECT name FROM sqlite_master WHERE type='table'\").all().map(t => t.name); console.log('Required tables:', ['stadion_change_detections', 'reverse_sync_state'].every(t => tables.includes(t)))"
```

2. Module exports verification:
```bash
node -e "const m = require('./lib/detect-stadion-changes'); console.log('Exports:', Object.keys(m))"
```

3. Self-test verification:
```bash
node lib/detect-stadion-changes.js
```

4. CLI entry point verification:
```bash
node detect-stadion-changes.js --help 2>&1 || node -e "console.log('CLI exists:', require('fs').existsSync('./detect-stadion-changes.js'))"
```
</verification>

<success_criteria>
- stadion_change_detections table created with proper indexes
- reverse_sync_state table created for tracking last detection
- tracked_fields_hash column added to stadion_members
- extractFieldValue() correctly extracts all 7 tracked fields from Stadion ACF structure
- computeTrackedFieldsHash() produces deterministic hashes
- Database helper functions work correctly
- Self-test passes with all expected values
- CLI entry point exists and follows module/CLI hybrid pattern
</success_criteria>

<output>
After completion, create `.planning/phases/22-stadion-change-detection/22-01-SUMMARY.md` following the summary template.
</output>
