---
phase: 22-stadion-change-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/detect-stadion-changes.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When hash changes, only fields with different old vs new values are logged"
    - "old_value in audit record contains the previous value from data_json"
    - "Unchanged fields within a changed hash are not logged as changes"
  artifacts:
    - path: "lib/detect-stadion-changes.js"
      provides: "Field-level change comparison within hash-changed members"
      contains: "if (oldValue === newValue)"
  key_links:
    - from: "lib/detect-stadion-changes.js"
      to: "stadion_change_detections table"
      via: "logChangeDetection with correct old_value"
      pattern: "old_value:\\s*oldValue"
---

<objective>
Fix false positive field change detection in Stadion change detection module.

Purpose: Currently, when a member's hash changes, ALL 7 tracked fields are logged as changed regardless of whether individual field values actually differ. This causes Phase 23 (reverse sync) to attempt syncing unchanged fields back to Sportlink, creating unnecessary operations and incorrect audit trails.

Output: Updated `lib/detect-stadion-changes.js` that compares individual field values and only logs fields that actually changed.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-stadion-change-detection/22-01-VERIFICATION.md
@lib/detect-stadion-changes.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix field-level comparison in detectChanges</name>
  <files>lib/detect-stadion-changes.js</files>
  <action>
In the detectChanges function (around lines 225-258), fix the field comparison logic:

1. After getting `parsedOldData` (line 235), extract the old value using the same `extractFieldValue` function:
   ```javascript
   const oldValue = extractFieldValue(parsedOldData, field);
   ```

2. Add comparison BEFORE creating the change object - skip if values are equal:
   ```javascript
   // Compare old vs new - skip if unchanged
   if (oldValue === newValue) {
     continue;
   }
   ```

3. Update the change object to use the actual oldValue instead of null:
   ```javascript
   old_value: oldValue !== null ? String(oldValue) : null,
   ```

4. Remove the dead code (lines 238-241) that queries `stadion_id` but never uses it:
   ```javascript
   // DELETE THIS:
   const oldValueStmt = db.prepare(`
     SELECT stadion_id FROM stadion_members WHERE knvb_id = ?
   `);
   const memberRecord = oldValueStmt.get(knvbId);
   ```

5. Update the verbose log to show both old and new values:
   ```javascript
   logger.verbose(`  - ${field}: ${oldValue} -> ${newValue}`);
   ```

The resulting loop should:
- Extract old value from stored data_json
- Compare old vs new for each field
- Only log fields that actually changed
- Include correct old_value in the audit record
  </action>
  <verify>
Run the module's self-test:
```bash
node lib/detect-stadion-changes.js
```

All existing tests should pass (field extraction, hash computation, database helpers).

Manually verify by reading the updated code and confirming:
1. `extractFieldValue(parsedOldData, field)` is called to get oldValue
2. `if (oldValue === newValue) continue;` skips unchanged fields
3. `old_value: oldValue !== null ? String(oldValue) : null,` in change object
4. Dead code removed
  </verify>
  <done>
When hash changes, only fields with actually different values are logged. The old_value field in the audit record contains the previous value from data_json, not null. Unchanged fields are skipped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit test for field-level comparison</name>
  <files>lib/detect-stadion-changes.js</files>
  <action>
Extend the self-test section (starting around line 279) to add a test that verifies field-level comparison works correctly:

Add "Test 4: Field-level comparison skips unchanged fields" after the existing tests:

```javascript
// Test 4: Field-level comparison (simulate)
console.log('Test 4: Field-level comparison skips unchanged fields');

const oldMemberData = {
  acf: {
    contact_info: [
      { contact_type: 'email', contact_value: 'john@example.com' },
      { contact_type: 'mobile', contact_value: '+31612345678' }
    ],
    'datum-vog': '2025-06-15',
    'freescout-id': 42
  }
};

const newMemberData = {
  acf: {
    contact_info: [
      { contact_type: 'email', contact_value: 'john.new@example.com' },  // CHANGED
      { contact_type: 'mobile', contact_value: '+31612345678' }  // UNCHANGED
    ],
    'datum-vog': '2025-06-15',  // UNCHANGED
    'freescout-id': 42  // UNCHANGED
  }
};

// Count how many fields are actually different
let changedCount = 0;
for (const field of TRACKED_FIELDS) {
  const oldVal = extractFieldValue(oldMemberData, field);
  const newVal = extractFieldValue(newMemberData, field);
  if (oldVal !== newVal) {
    changedCount++;
    console.log(`  ${field}: "${oldVal}" -> "${newVal}" (CHANGED)`);
  }
}

console.log(`  Total changed fields: ${changedCount} (expected: 1 - only email)`);
console.log('');
```

This test demonstrates that the extractFieldValue + comparison logic correctly identifies only the email field as changed.
  </action>
  <verify>
Run the self-test again:
```bash
node lib/detect-stadion-changes.js
```

Verify Test 4 output shows:
- email: "john@example.com" -> "john.new@example.com" (CHANGED)
- Total changed fields: 1 (expected: 1 - only email)
  </verify>
  <done>
Self-test includes verification that field-level comparison correctly identifies only actually changed fields, not all tracked fields.
  </done>
</task>

</tasks>

<verification>
1. Run `node lib/detect-stadion-changes.js` - all 4 tests pass
2. Read the updated code at lines 225-260 and confirm:
   - oldValue extracted via extractFieldValue(parsedOldData, field)
   - continue statement skips when oldValue === newValue
   - old_value in change object uses actual oldValue
   - Dead code (stadion_id query) removed
3. Grep for the fix pattern: `grep "oldValue === newValue" lib/detect-stadion-changes.js` returns a match
</verification>

<success_criteria>
- Self-test passes including new Test 4
- When hash differs, only fields with different old vs new values are logged
- old_value in audit records contains actual previous value from data_json
- Dead code (unused stadion_id query) removed
- Verification report can be re-run with all 4 truths passing
</success_criteria>

<output>
After completion, create `.planning/phases/22-stadion-change-detection/22-02-SUMMARY.md`
</output>
