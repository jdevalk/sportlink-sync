---
phase: 26-wire-conflict-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - submit-stadion-sync.js
autonomous: true

must_haves:
  truths:
    - "Conflicts between Sportlink and Stadion are detected during forward sync UPDATE operations"
    - "Last-edit-wins logic determines which value is used based on timestamp comparison"
    - "Operator sees conflict details in email reports when conflicts occur"
    - "Conflict resolutions are logged to audit table for debugging"
  artifacts:
    - path: "submit-stadion-sync.js"
      provides: "Conflict resolution integration in forward sync"
      contains: "resolveFieldConflicts"
  key_links:
    - from: "submit-stadion-sync.js"
      to: "lib/conflict-resolver.js"
      via: "require and function call"
      pattern: "resolveFieldConflicts\\("
    - from: "submit-stadion-sync.js"
      to: "lib/conflict-resolver.js"
      via: "require and function call"
      pattern: "generateConflictSummary\\("
---

<objective>
Wire the conflict resolution infrastructure (Phase 21) to the forward sync pipeline so bidirectional conflicts are detected and resolved during member updates.

Purpose: Complete the bidirectional sync loop by detecting when both Sportlink and Stadion have modified the same field and applying last-edit-wins resolution. Without this wiring, forward sync silently overwrites Stadion edits, causing data loss.

Output: submit-stadion-sync.js calls resolveFieldConflicts() during UPDATE operations, applies winning values, logs conflicts to audit table, and includes conflict summary in email reports.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevolk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-wire-conflict-resolution/26-CONTEXT.md
@.planning/phases/26-wire-conflict-resolution/26-RESEARCH.md
@.planning/phases/21-conflict-resolution-infrastructure/21-01-SUMMARY.md

# Source files to modify
@submit-stadion-sync.js
@lib/conflict-resolver.js
@lib/sync-origin.js
@lib/detect-stadion-changes.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conflict resolution integration to syncPerson UPDATE path</name>
  <files>submit-stadion-sync.js</files>
  <action>
Integrate conflict resolution into submit-stadion-sync.js:

1. Add imports at top of file:
```javascript
const { resolveFieldConflicts, generateConflictSummary } = require('./lib/conflict-resolver');
const { TRACKED_FIELDS } = require('./lib/sync-origin');
```

2. Add helper function `extractTrackedFieldValues(data)` that extracts tracked fields from ACF data:
   - Handle contact_info repeater (Stadion stores email/email2/mobile/phone there)
   - Handle direct ACF fields (datum-vog, freescout-id, financiele-blokkade)
   - Use the same logic as lib/detect-stadion-changes.js extractFieldValue()
   - Return object with field names as keys (using underscores: email, email2, datum_vog, etc.)

3. Add helper function `applyResolutions(originalData, resolutions)` that:
   - Deep clones originalData
   - Iterates over resolutions Map
   - Converts field names (underscores to hyphens for ACF: datum_vog -> datum-vog)
   - Applies winning values to resolvedData.acf
   - Returns the modified data

4. Modify syncPerson() UPDATE path (when stadion_id exists):
   - After fetching existing data (line 76), before the PUT request
   - Extract tracked field values from both sportlink (data) and stadion (existing.body)
   - Call resolveFieldConflicts(member, sportlinkData, stadionData, db, options.logger)
   - Store conflicts array for return
   - Apply resolutions to update payload using applyResolutions()
   - Log verbose message if conflicts detected: "Resolved N conflict(s) for {knvb_id}"
   - Return conflicts array in syncResult: { action: 'updated', id: stadion_id, conflicts }

5. CREATE path should return empty conflicts array: { action: 'created', id: newId, conflicts: [] }

IMPORTANT per CONTEXT.md:
- Skip member and continue sync if conflict resolution fails (try/catch around resolution logic)
- Log detailed error for skipped member but do NOT throw/abort entire sync
- Sportlink wins on timestamp tie (grace period) - this is already handled by conflict-resolver.js
- Only resolve conflicts for tracked fields (TRACKED_FIELDS constant)
  </action>
  <verify>
Run self-test: `node submit-stadion-sync.js --verbose 2>&1 | head -50`
Confirm no import errors and script starts normally.
  </verify>
  <done>
syncPerson() calls resolveFieldConflicts() during UPDATE and returns conflicts array.
Helper functions extractTrackedFieldValues() and applyResolutions() are implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add conflict aggregation and email summary to runSync</name>
  <files>submit-stadion-sync.js</files>
  <action>
Modify runSync() to aggregate conflicts and generate email summary:

1. Add `conflicts: 0` to result object initialization (line ~558)

2. Create `const allConflicts = [];` before the member sync loop

3. Inside the member sync loop, after successful syncResult:
```javascript
if (syncResult.conflicts && syncResult.conflicts.length > 0) {
  allConflicts.push(...syncResult.conflicts);
}
```

4. After the member sync loop completes (after deleteRemovedMembers), add conflict summary:
```javascript
// Generate and log conflict summary for email report
if (allConflicts.length > 0) {
  const summary = generateConflictSummary(allConflicts);
  if (logger) {
    logger.log(''); // Blank line separator
    logger.log(summary); // "CONFLICTS DETECTED AND RESOLVED" section
  }
  result.conflicts = allConflicts.length;
}
```

5. Ensure error handling per CONTEXT.md: if conflict resolution fails for one member, log error and continue with next member (don't abort sync).

The generateConflictSummary() function from lib/conflict-resolver.js produces email-compatible plain text that formatAsHtml() will convert to proper HTML with H2 headers.
  </action>
  <verify>
Verify code compiles: `node -c submit-stadion-sync.js`
Inspect the runSync function to confirm conflict aggregation logic is present.
  </verify>
  <done>
runSync() aggregates conflicts from all syncPerson() calls and generates email summary.
Email reports will show "CONFLICTS DETECTED AND RESOLVED" section when conflicts occur.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration on production server</name>
  <files>submit-stadion-sync.js</files>
  <action>
Deploy and verify on production server:

1. SSH to production: `ssh root@46.202.155.16`
2. Navigate to project: `cd /home/sportlink`
3. Pull latest code: `git pull`
4. Run verbose sync to verify no errors:
   `node submit-stadion-sync.js --verbose 2>&1 | head -100`

5. Check for:
   - No import errors
   - "Resolved N conflict(s)" messages if conflicts exist
   - No crashes during sync
   - Sync completes successfully

6. Query audit table to verify conflicts are logged:
   `sqlite3 stadion-sync.sqlite "SELECT COUNT(*) FROM conflict_resolutions WHERE resolved_at > datetime('now', '-1 hour')"`

Note: If no actual bidirectional edits have occurred, there may be zero conflicts - that's expected. The important verification is that the code runs without errors.
  </action>
  <verify>
Production sync completes without errors.
Conflict resolution code executes (visible in verbose output).
Audit table accessible and queryable.
  </verify>
  <done>
Integration verified on production server.
Forward sync with conflict resolution works end-to-end.
  </done>
</task>

</tasks>

<verification>
Phase 26 is complete when:
1. `grep -n "resolveFieldConflicts" submit-stadion-sync.js` shows import and call
2. `grep -n "generateConflictSummary" submit-stadion-sync.js` shows import and call
3. `grep -n "allConflicts" submit-stadion-sync.js` shows aggregation array
4. `grep -n "extractTrackedFieldValues" submit-stadion-sync.js` shows helper function
5. `node -c submit-stadion-sync.js` passes (no syntax errors)
6. Production sync runs without errors
</verification>

<success_criteria>
- [ ] submit-stadion-sync.js imports resolveFieldConflicts and generateConflictSummary
- [ ] extractTrackedFieldValues() helper extracts tracked fields from both data formats
- [ ] applyResolutions() helper applies winning values to update payload
- [ ] syncPerson() UPDATE path calls resolveFieldConflicts() before PUT
- [ ] syncPerson() returns conflicts array in result
- [ ] runSync() aggregates conflicts from all members
- [ ] runSync() generates and logs conflict summary when conflicts exist
- [ ] Error handling: individual member errors don't abort entire sync
- [ ] Production server sync completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/26-wire-conflict-resolution/26-01-SUMMARY.md`
</output>
