---
phase: 10-photo-download
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .gitignore
  - download-photos-from-sportlink.js
  - lib/stadion-db.js
autonomous: true

must_haves:
  truths:
    - "System queries SQLite for members with photo_state='pending_download'"
    - "System navigates to Sportlink member detail page for each member"
    - "System opens photo modal and extracts image data"
    - "Photos saved to photos/<knvb_id>.<ext> with correct format extension"
    - "Photo state updated to 'downloaded' after successful save"
    - "Failed downloads logged with error reason, processing continues"
  artifacts:
    - path: "photos/"
      provides: "Directory for downloaded member photos"
    - path: "download-photos-from-sportlink.js"
      provides: "Photo download script with browser automation"
      exports: ["runPhotoDownload"]
      min_lines: 150
  key_links:
    - from: "download-photos-from-sportlink.js"
      to: "lib/stadion-db.js"
      via: "getMembersByPhotoState, updatePhotoState"
      pattern: "getMembersByPhotoState.*pending_download"
    - from: "download-photos-from-sportlink.js"
      to: "Sportlink browser session"
      via: "Playwright page navigation and modal interaction"
      pattern: "page\\.goto.*member"
---

<objective>
Create photo download script that extracts member photos from Sportlink via browser automation.

Purpose: Enable downloading photos for members with PersonImageDate, the first step in photo sync pipeline
Output: `download-photos-from-sportlink.js` script that downloads photos to `photos/` directory
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-photo-download/10-CONTEXT.md
@.planning/phases/10-photo-download/10-RESEARCH.md
@.planning/phases/09-photo-state-tracking/09-01-SUMMARY.md

# Source files to extend/reference
@download-data-from-sportlink.js
@lib/stadion-db.js
@lib/logger.js
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup Photos Directory and Gitignore</name>
  <files>.gitignore</files>
  <action>
Add `photos/` to `.gitignore` under the Data section (after `stadion-sync.sqlite`).

The actual photos/ directory will be created programmatically by the download script (like logs/ is created by logger.js), not manually.
  </action>
  <verify>
- `grep "photos/" .gitignore` shows the entry
  </verify>
  <done>
- photos/ directory is gitignored
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Photo Download Script</name>
  <files>download-photos-from-sportlink.js, lib/stadion-db.js</files>
  <action>
Create `download-photos-from-sportlink.js` following the module/CLI hybrid pattern from existing scripts.

**Script structure:**

1. **Imports and helpers:**
   - `require('varlock/auto-load')` for env loading
   - Import from `lib/stadion-db.js`: `openDb`, `getMembersByPhotoState`, `updatePhotoState`
   - Import from `lib/logger.js`: `createSyncLogger`
   - Import `chromium` from `playwright`
   - Import `otplib` for OTP generation
   - Import `fs/promises` and `path` for file operations

2. **MIME type to extension mapping:**
   ```javascript
   const MIME_TO_EXT = {
     'image/jpeg': 'jpg',
     'image/png': 'png',
     'image/webp': 'webp',
     'image/gif': 'gif'
   };
   ```

3. **Directory setup function:**
   ```javascript
   async function ensurePhotosDir() {
     const photosDir = path.join(process.cwd(), 'photos');
     await fs.mkdir(photosDir, { recursive: true });
     return photosDir;
   }
   ```

4. **Login function (reuse pattern from download-data-from-sportlink.js):**
   ```javascript
   async function loginToSportlink(page, logger) {
     // Same login flow as download-data-from-sportlink.js
     // Returns true on success, throws on failure
   }
   ```

5. **Photo download function for single member:**
   ```javascript
   async function downloadMemberPhoto(page, context, knvbId, photosDir, logger) {
     // Navigate to member detail page: https://club.sportlink.com/member/detail/<knvbId>
     // Wait for page load
     // Find and click photo thumbnail/avatar element
     // Wait for modal with full-size image
     // Extract image URL from modal img element
     // Fetch image using context.request.get(imgUrl)
     // Determine extension from Content-Type header
     // Save to photos/<knvbId>.<ext>
     // Return { success: true, path: filePath } or throw error
   }
   ```

6. **Main orchestration function:**
   ```javascript
   async function runPhotoDownload(options = {}) {
     const { logger: providedLogger, verbose = false } = options;
     const logger = providedLogger || createSyncLogger({ verbose });

     const result = {
       success: true,
       total: 0,
       downloaded: 0,
       skipped: 0,
       failed: 0,
       errors: []
     };

     const db = openDb();
     try {
       // Get members needing photo download
       const members = getMembersByPhotoState(db, 'pending_download');
       result.total = members.length;

       if (members.length === 0) {
         logger.log('No photos pending download');
         return result;
       }

       logger.log(`${members.length} photos pending download`);

       const photosDir = await ensurePhotosDir();

       // Launch browser and login
       const browser = await chromium.launch({ headless: true });
       const context = await browser.newContext({ ... });
       const page = await context.newPage();

       try {
         await loginToSportlink(page, logger);

         // Process each member sequentially
         for (let i = 0; i < members.length; i++) {
           const member = members[i];
           logger.verbose(`Downloading photo ${i + 1}/${members.length}: ${member.knvb_id}`);

           try {
             const photoResult = await downloadMemberPhoto(page, context, member.knvb_id, photosDir, logger);
             updatePhotoState(db, member.knvb_id, 'downloaded');
             result.downloaded++;
           } catch (error) {
             result.failed++;
             result.errors.push({ knvb_id: member.knvb_id, message: error.message });
             logger.verbose(`Failed: ${member.knvb_id} - ${error.message}`);
             // Continue to next member
           }

           // Random delay 1-3 seconds between members
           if (i < members.length - 1) {
             const delay = 1000 + Math.random() * 2000;
             await new Promise(r => setTimeout(r, delay));
           }
         }
       } finally {
         await browser.close();
       }

       // Summary
       logger.log(`Downloaded ${result.downloaded}/${result.total} photos`);
       if (result.failed > 0) {
         logger.log(`Failed: ${result.failed}`);
       }

       result.success = result.errors.length === 0;
       return result;

     } finally {
       db.close();
     }
   }
   ```

7. **CLI entry point:**
   ```javascript
   module.exports = { runPhotoDownload };

   if (require.main === module) {
     const verbose = process.argv.includes('--verbose');
     runPhotoDownload({ verbose })
       .then(result => {
         if (!result.success) process.exitCode = 1;
       })
       .catch(err => {
         console.error('Error:', err.message);
         process.exitCode = 1;
       });
   }
   ```

**Key implementation details:**

- **Member detail page URL:** Use `https://club.sportlink.com/member/detail/${knvbId}` - the knvbId is the relatiecode used throughout the system

- **Photo extraction strategy:** Start with checking for img element with photo. If photo is in a thumbnail that opens a modal, click it and wait for modal. Use `page.waitForSelector` with appropriate selectors. The exact selectors will need to be discovered during implementation by inspecting the Sportlink page structure.

- **Fallback approach:** If modal approach doesn't work, try extracting image URL directly from the detail page DOM.

- **Content-Type handling:** Use the MIME_TO_EXT mapping. Default to `.jpg` if Content-Type is unrecognized or missing.

- **Error handling:** Wrap individual member downloads in try/catch. Log error, add to errors array, continue processing. Don't let one failure stop the batch.

- **Natural pacing:** Use `1000 + Math.random() * 2000` for delays (1-3 seconds) between member downloads to avoid rate limiting.

**Also add to lib/stadion-db.js:**

Add a helper function to track download errors (optional enhancement for retry capability):

```javascript
/**
 * Get members by photo state (enhanced to include data needed for download)
 * Returns knvb_id for URL construction
 */
// Already exists as getMembersByPhotoState - no changes needed
```

The existing `getMembersByPhotoState` already returns knvb_id which is what we need for the member detail URL.
  </action>
  <verify>
- `node download-photos-from-sportlink.js --verbose` runs without syntax errors
- Script logs "No photos pending download" or starts processing members
- If photos exist: photos appear in `photos/` directory with correct extensions
- `ls photos/` shows downloaded files (if any pending)
  </verify>
  <done>
- Script downloads photos from Sportlink member detail pages
- Photos saved as `photos/<knvb_id>.<ext>` with format-appropriate extension
- Photo state updated to 'downloaded' after successful download
- Failed downloads logged, processing continues
- Summary shows downloaded/failed counts
  </done>
</task>

</tasks>

<verification>
Run the photo download script and verify:

1. **No pending photos scenario:**
   ```bash
   node download-photos-from-sportlink.js
   # Should output: "No photos pending download" (if no pending_download state)
   ```

2. **With pending photos:**
   ```bash
   node download-photos-from-sportlink.js --verbose
   # Should show progress for each member
   # Should create files in photos/ directory
   ```

3. **Check database state:**
   ```bash
   sqlite3 stadion-sync.sqlite "SELECT photo_state, COUNT(*) FROM stadion_members GROUP BY photo_state"
   # Should show 'downloaded' count after running
   ```

4. **Check photo files:**
   ```bash
   ls -la photos/
   file photos/*.jpg photos/*.png photos/*.webp 2>/dev/null
   # Files should have correct format based on extension
   ```
</verification>

<success_criteria>
- Script runs without errors
- Photos downloaded to `photos/<knvb_id>.<ext>` with correct format
- Photo state transitions from 'pending_download' to 'downloaded'
- Failed downloads don't crash the script
- Summary output shows download statistics
- Requirements PHOTO-01, PHOTO-02, PHOTO-03 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/10-photo-download/10-01-SUMMARY.md`
</output>
