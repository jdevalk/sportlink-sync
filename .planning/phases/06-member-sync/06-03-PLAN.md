---
phase: 06-member-sync
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - submit-stadion-sync.js
autonomous: true

must_haves:
  truths:
    - "New Sportlink members create new persons in Stadion"
    - "Changed member data updates existing Stadion persons"
    - "Unchanged members are skipped (no API call)"
    - "Members are matched by KNVB ID first, then email fallback"
    - "Members deleted from Sportlink are deleted from Stadion"
    - "Sync continues after individual errors"
  artifacts:
    - path: "submit-stadion-sync.js"
      provides: "Stadion sync execution"
      exports: ["runSync"]
  key_links:
    - from: "submit-stadion-sync.js"
      to: "lib/stadion-client.js"
      via: "stadionRequest"
      pattern: "stadionRequest"
    - from: "submit-stadion-sync.js"
      to: "lib/stadion-db.js"
      via: "hash-based change detection"
      pattern: "getMembersNeedingSync"
    - from: "submit-stadion-sync.js"
      to: "prepare-stadion-members.js"
      via: "runPrepare"
      pattern: "runPrepare"
---

<objective>
Create Stadion sync execution script that creates, updates, and deletes person records.

Purpose: Execute the actual synchronization to Stadion WordPress, handling matching logic, API operations, and error recovery.

Output: `submit-stadion-sync.js` that syncs prepared members to Stadion with full create/update/delete support.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-member-sync/06-CONTEXT.md
@.planning/phases/06-member-sync/06-RESEARCH.md
@.planning/phases/06-member-sync/06-01-SUMMARY.md
@.planning/phases/06-member-sync/06-02-SUMMARY.md
@submit-laposta-list.js
@lib/stadion-client.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create submit-stadion-sync.js with matching and sync logic</name>
  <files>submit-stadion-sync.js</files>
  <action>
Create `submit-stadion-sync.js` following the pattern from `submit-laposta-list.js`:

1. **Module setup:**
   - Use varlock/auto-load for env loading
   - Import stadionRequest from lib/stadion-client.js
   - Import runPrepare from prepare-stadion-members.js
   - Import stadion-db functions (openDb, upsertMembers, getMembersNeedingSync, updateSyncState, deleteMember, getMembersNotInList)
   - Module/CLI hybrid pattern

2. **Read person type from env:**
   ```javascript
   const PERSON_TYPE = readEnv('STADION_PERSON_TYPE', 'person');
   // API endpoint will be: wp/v2/{PERSON_TYPE}
   ```

3. **Matching function (KNVB ID first, email fallback):**
   ```javascript
   async function findExistingPerson(knvbId, email, options) {
     const { logger, verbose } = options;
     const logVerbose = logger ? logger.verbose.bind(logger) : (verbose ? console.log : () => {});

     // Try KNVB ID match first
     if (knvbId) {
       try {
         const response = await stadionRequest(
           `wp/v2/${PERSON_TYPE}?meta_key=knvb_id&meta_value=${encodeURIComponent(knvbId)}`,
           'GET',
           null,
           options
         );
         if (response.body && response.body.length > 0) {
           logVerbose(`Matched by KNVB ID: ${knvbId}`);
           return response.body[0];
         }
       } catch (error) {
         logVerbose(`KNVB ID search failed: ${error.message}`);
       }
     }

     // Fallback: email match
     if (email) {
       try {
         // Search by email in contact_info ACF field may require custom endpoint
         // For now, search by title or use a simple search endpoint
         const response = await stadionRequest(
           `wp/v2/${PERSON_TYPE}?search=${encodeURIComponent(email)}`,
           'GET',
           null,
           options
         );
         if (response.body && response.body.length > 0) {
           // Verify email match in response
           for (const person of response.body) {
             const contactInfo = person.acf?.contact_info || [];
             const hasEmail = contactInfo.some(c =>
               c.type === 'email' && c.value.toLowerCase() === email.toLowerCase()
             );
             if (hasEmail) {
               logVerbose(`Matched by email: ${email}`);
               return person;
             }
           }
         }
       } catch (error) {
         logVerbose(`Email search failed: ${error.message}`);
       }
     }

     return null; // No match found
   }
   ```

4. **Sync single person function:**
   ```javascript
   async function syncPerson(member, db, options) {
     const { knvb_id, email, data, source_hash } = member;
     const logVerbose = options.logger?.verbose.bind(options.logger) || (options.verbose ? console.log : () => {});

     const existing = await findExistingPerson(knvb_id, email, options);

     if (existing) {
       // UPDATE existing person
       // Backfill KNVB ID if matched by email and missing
       if (!existing.meta?.knvb_id && knvb_id) {
         data.meta.knvb_id = knvb_id;
       }

       const response = await stadionRequest(
         `wp/v2/${PERSON_TYPE}/${existing.id}`,
         'POST', // WordPress uses POST for updates too (with ID in URL)
         data,
         options
       );
       updateSyncState(db, knvb_id, source_hash, existing.id);
       return { action: 'updated', id: existing.id };
     } else {
       // CREATE new person
       const response = await stadionRequest(
         `wp/v2/${PERSON_TYPE}`,
         'POST',
         data,
         options
       );
       const newId = response.body.id;
       updateSyncState(db, knvb_id, source_hash, newId);
       return { action: 'created', id: newId };
     }
   }
   ```

5. **Delete detection and execution:**
   ```javascript
   async function deleteRemovedMembers(db, currentKnvbIds, options) {
     const logVerbose = options.logger?.verbose.bind(options.logger) || (options.verbose ? console.log : () => {});
     const deleted = [];
     const errors = [];

     // Find members in DB but not in current Sportlink data
     const toDelete = getMembersNotInList(db, currentKnvbIds);

     for (const member of toDelete) {
       if (!member.stadion_id) {
         // Never synced to Stadion, just remove from tracking
         deleteMember(db, member.knvb_id);
         continue;
       }

       logVerbose(`Deleting from Stadion: ${member.knvb_id}`);
       try {
         await stadionRequest(
           `wp/v2/${PERSON_TYPE}/${member.stadion_id}`,
           'DELETE',
           null,
           options
         );
         deleteMember(db, member.knvb_id);
         deleted.push({ knvb_id: member.knvb_id, stadion_id: member.stadion_id });
       } catch (error) {
         errors.push({ knvb_id: member.knvb_id, message: error.message });
       }

       // Rate limit
       await sleep(2000);
     }

     return { deleted, errors };
   }
   ```

6. **Main sync function with rate limiting:**
   ```javascript
   async function runSync(options = {}) {
     const { logger, verbose = false, force = false } = options;
     const logVerbose = logger?.verbose.bind(logger) || (verbose ? console.log : () => {});
     const logError = logger?.error.bind(logger) || console.error;

     const result = {
       success: true,
       total: 0,
       synced: 0,
       created: 0,
       updated: 0,
       skipped: 0,
       deleted: 0,
       errors: []
     };

     try {
       // Step 1: Prepare members from Sportlink
       const prepared = await runPrepare({ logger, verbose });
       if (!prepared.success) {
         result.success = false;
         result.error = prepared.error;
         return result;
       }

       const members = prepared.members;
       result.total = members.length;

       // Step 2: Upsert to tracking database
       const db = openDb();
       try {
         upsertMembers(db, members);

         // Step 3: Get members needing sync (hash changed or force)
         const needsSync = getMembersNeedingSync(db, force);
         result.skipped = result.total - needsSync.length;

         logVerbose(`${needsSync.length} members need sync (${result.skipped} unchanged)`);

         // Step 4: Sync each member
         for (let i = 0; i < needsSync.length; i++) {
           const member = needsSync[i];
           logVerbose(`Syncing ${i + 1}/${needsSync.length}: ${member.knvb_id}`);

           try {
             const syncResult = await syncPerson(member, db, options);
             result.synced++;
             if (syncResult.action === 'created') result.created++;
             if (syncResult.action === 'updated') result.updated++;
           } catch (error) {
             result.errors.push({
               knvb_id: member.knvb_id,
               email: member.email,
               message: error.message
             });
           }

           // Rate limit: 2 seconds between requests
           if (i < needsSync.length - 1) {
             await sleep(2000);
           }
         }

         // Step 5: Delete members removed from Sportlink
         const currentKnvbIds = members.map(m => m.knvb_id);
         const deleteResult = await deleteRemovedMembers(db, currentKnvbIds, options);
         result.deleted = deleteResult.deleted.length;
         result.errors.push(...deleteResult.errors);

       } finally {
         db.close();
       }

       result.success = result.errors.length === 0;
       return result;

     } catch (error) {
       result.success = false;
       result.error = error.message;
       logError(`Sync error: ${error.message}`);
       return result;
     }
   }

   function sleep(ms) {
     return new Promise(resolve => setTimeout(resolve, ms));
   }
   ```

7. **CLI entry point:**
   ```javascript
   if (require.main === module) {
     const verbose = process.argv.includes('--verbose');
     const force = process.argv.includes('--force');

     runSync({ verbose, force })
       .then(result => {
         console.log(`Stadion sync: ${result.synced}/${result.total} synced`);
         console.log(`  Created: ${result.created}`);
         console.log(`  Updated: ${result.updated}`);
         console.log(`  Skipped: ${result.skipped}`);
         console.log(`  Deleted: ${result.deleted}`);
         if (result.errors.length > 0) {
           console.error(`  Errors: ${result.errors.length}`);
           result.errors.forEach(e => console.error(`    - ${e.knvb_id}: ${e.message}`));
           process.exitCode = 1;
         }
       })
       .catch(err => {
         console.error('Error:', err.message);
         process.exitCode = 1;
       });
   }
   ```

8. **Export for pipeline integration (Phase 8):**
   ```javascript
   module.exports = { runSync };
   ```
  </action>
  <verify>
1. Run `node --check submit-stadion-sync.js` - syntax valid
2. Verify module loads: `node -e "require('./submit-stadion-sync')"`
3. Test CLI (will fail without Stadion credentials, but should show proper error):
   `node submit-stadion-sync.js --verbose`
4. Verify exports: runSync function is exported
  </verify>
  <done>
- submit-stadion-sync.js exists and exports runSync
- Matching logic: KNVB ID first, email fallback
- Create/update/delete operations implemented
- Rate limiting (2 seconds between requests)
- Error collection continues sync on individual failures
- CLI shows sync summary
  </done>
</task>

<task type="auto">
  <name>Task 2: Add npm script for Stadion sync</name>
  <files>package.json</files>
  <action>
Add npm script for Stadion sync to package.json:

```json
{
  "scripts": {
    "sync-stadion": "node submit-stadion-sync.js",
    "sync-stadion-verbose": "node submit-stadion-sync.js --verbose"
  }
}
```

Add these to the existing scripts section, keeping all existing scripts intact.
  </action>
  <verify>
1. Run `npm run sync-stadion --help` or check package.json manually
2. Verify both scripts added: sync-stadion and sync-stadion-verbose
  </verify>
  <done>
- package.json has sync-stadion script
- package.json has sync-stadion-verbose script
  </done>
</task>

</tasks>

<verification>
1. All modules load without errors
2. npm run sync-stadion executes (may fail on credentials, but syntax OK)
3. Sync result includes: total, synced, created, updated, skipped, deleted, errors
4. Error handling: individual failures don't stop sync
5. Rate limiting: 2 second delay between API calls
</verification>

<success_criteria>
- submit-stadion-sync.js created with runSync export
- Matching logic: KNVB ID first, email fallback with backfill
- Create, update, and delete operations all implemented
- Hash-based change detection skips unchanged members
- Sync continues after individual errors
- npm scripts added for running sync
</success_criteria>

<output>
After completion, create `.planning/phases/06-member-sync/06-03-SUMMARY.md`
</output>
