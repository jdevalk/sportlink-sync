---
phase: 06-member-sync
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - submit-stadion-sync.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "New Sportlink members create new persons in Stadion"
    - "Changed member data updates existing Stadion persons"
    - "Unchanged members are skipped (no API call)"
    - "Members are matched by KNVB ID first, then email fallback"
    - "Members deleted from Sportlink are deleted from Stadion"
    - "Sync continues after individual errors"
  artifacts:
    - path: "submit-stadion-sync.js"
      provides: "Stadion sync execution"
      exports: ["runSync"]
  key_links:
    - from: "submit-stadion-sync.js"
      to: "lib/stadion-client.js"
      via: "stadionRequest"
      pattern: "stadionRequest"
    - from: "submit-stadion-sync.js"
      to: "lib/stadion-db.js"
      via: "hash-based change detection"
      pattern: "getMembersNeedingSync"
    - from: "submit-stadion-sync.js"
      to: "prepare-stadion-members.js"
      via: "runPrepare"
      pattern: "runPrepare"
---

<objective>
Create Stadion sync execution script that creates, updates, and deletes person records.

Purpose: Execute the actual synchronization to Stadion WordPress, handling matching logic, API operations, and error recovery.

Output: `submit-stadion-sync.js` that syncs prepared members to Stadion with full create/update/delete support.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-member-sync/06-CONTEXT.md
@.planning/phases/06-member-sync/06-RESEARCH.md
@submit-laposta-list.js
@lib/stadion-client.js
@lib/stadion-db.js
@prepare-stadion-members.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create submit-stadion-sync.js with matching and sync logic</name>
  <files>submit-stadion-sync.js</files>
  <action>
Create `submit-stadion-sync.js` with matching and person sync functions:

1. **Module setup:**
   - Use varlock/auto-load for env loading
   - Import stadionRequest from lib/stadion-client.js
   - Import runPrepare from prepare-stadion-members.js
   - Import stadion-db functions (openDb, upsertMembers, getMembersNeedingSync, updateSyncState)
   - Module/CLI hybrid pattern

2. **Read person type from env:**
   ```javascript
   const PERSON_TYPE = readEnv('STADION_PERSON_TYPE', 'person');
   // API endpoint will be: wp/v2/{PERSON_TYPE}
   ```

3. **Matching function (KNVB ID first, email fallback with client-side filtering):**
   ```javascript
   async function findExistingPerson(knvbId, email, options) {
     const { logger, verbose } = options;
     const logVerbose = logger ? logger.verbose.bind(logger) : (verbose ? console.log : () => {});

     // Try KNVB ID match first (meta query)
     if (knvbId) {
       try {
         const response = await stadionRequest(
           `wp/v2/${PERSON_TYPE}?meta_key=knvb_id&meta_value=${encodeURIComponent(knvbId)}`,
           'GET',
           null,
           options
         );
         if (response.body && response.body.length > 0) {
           logVerbose(`Matched by KNVB ID: ${knvbId}`);
           return response.body[0];
         }
       } catch (error) {
         logVerbose(`KNVB ID search failed: ${error.message}`);
       }
     }

     // Fallback: email match with client-side filtering
     // WordPress search won't find ACF contact_info fields, so we:
     // 1. Search by email as general search term (may match title/content)
     // 2. Fetch results and filter client-side for actual ACF email match
     if (email) {
       try {
         // Use general search - will match if email appears in any indexed field
         const response = await stadionRequest(
           `wp/v2/${PERSON_TYPE}?search=${encodeURIComponent(email)}&per_page=20`,
           'GET',
           null,
           options
         );
         if (response.body && response.body.length > 0) {
           // Client-side filter: check ACF contact_info for exact email match
           for (const person of response.body) {
             const contactInfo = person.acf?.contact_info || [];
             const hasEmail = contactInfo.some(c =>
               c.type === 'email' && c.value?.toLowerCase() === email.toLowerCase()
             );
             if (hasEmail) {
               logVerbose(`Matched by email (client-side filter): ${email}`);
               return person;
             }
           }
         }

         // If search didn't find it, try fetching recent persons and filtering
         // This handles case where email isn't in indexed fields
         logVerbose(`Email not in search results, checking recent persons...`);
         const recentResponse = await stadionRequest(
           `wp/v2/${PERSON_TYPE}?per_page=100&orderby=modified&order=desc`,
           'GET',
           null,
           options
         );
         if (recentResponse.body && recentResponse.body.length > 0) {
           for (const person of recentResponse.body) {
             const contactInfo = person.acf?.contact_info || [];
             const hasEmail = contactInfo.some(c =>
               c.type === 'email' && c.value?.toLowerCase() === email.toLowerCase()
             );
             if (hasEmail) {
               logVerbose(`Matched by email (recent persons scan): ${email}`);
               return person;
             }
           }
         }
       } catch (error) {
         logVerbose(`Email search failed: ${error.message}`);
       }
     }

     return null; // No match found
   }
   ```

4. **Sync single person function:**
   ```javascript
   async function syncPerson(member, db, options) {
     const { knvb_id, email, data, source_hash } = member;
     const logVerbose = options.logger?.verbose.bind(options.logger) || (options.verbose ? console.log : () => {});

     const existing = await findExistingPerson(knvb_id, email, options);

     if (existing) {
       // UPDATE existing person
       // Backfill KNVB ID if matched by email and missing
       if (!existing.meta?.knvb_id && knvb_id) {
         data.meta.knvb_id = knvb_id;
       }

       const response = await stadionRequest(
         `wp/v2/${PERSON_TYPE}/${existing.id}`,
         'POST', // WordPress uses POST for updates too (with ID in URL)
         data,
         options
       );
       updateSyncState(db, knvb_id, source_hash, existing.id);
       return { action: 'updated', id: existing.id };
     } else {
       // CREATE new person
       const response = await stadionRequest(
         `wp/v2/${PERSON_TYPE}`,
         'POST',
         data,
         options
       );
       const newId = response.body.id;
       updateSyncState(db, knvb_id, source_hash, newId);
       return { action: 'created', id: newId };
     }
   }
   ```

5. **Helper for rate limiting:**
   ```javascript
   function sleep(ms) {
     return new Promise(resolve => setTimeout(resolve, ms));
   }
   ```

6. **Export syncPerson and findExistingPerson for use by Task 2:**
   - These functions will be used by the main runSync orchestration
  </action>
  <verify>
1. Run `node --check submit-stadion-sync.js` - syntax valid
2. Verify findExistingPerson handles both KNVB ID and email fallback paths
3. Verify syncPerson returns { action: 'created'|'updated', id: number }
  </verify>
  <done>
- submit-stadion-sync.js has findExistingPerson with KNVB ID + email fallback
- Email fallback uses client-side filtering (fetches persons, filters by ACF contact_info)
- syncPerson handles create and update operations
- Rate limiting helper function exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Add delete detection and main runSync orchestration</name>
  <files>submit-stadion-sync.js</files>
  <action>
Add delete detection and main orchestration to submit-stadion-sync.js:

1. **Import additional stadion-db functions:**
   ```javascript
   const { deleteMember, getMembersNotInList } = require('./lib/stadion-db');
   ```

2. **Delete detection and execution:**
   ```javascript
   async function deleteRemovedMembers(db, currentKnvbIds, options) {
     const logVerbose = options.logger?.verbose.bind(options.logger) || (options.verbose ? console.log : () => {});
     const deleted = [];
     const errors = [];

     // Find members in DB but not in current Sportlink data
     const toDelete = getMembersNotInList(db, currentKnvbIds);

     for (const member of toDelete) {
       if (!member.stadion_id) {
         // Never synced to Stadion, just remove from tracking
         deleteMember(db, member.knvb_id);
         continue;
       }

       logVerbose(`Deleting from Stadion: ${member.knvb_id}`);
       try {
         await stadionRequest(
           `wp/v2/${PERSON_TYPE}/${member.stadion_id}`,
           'DELETE',
           null,
           options
         );
         deleteMember(db, member.knvb_id);
         deleted.push({ knvb_id: member.knvb_id, stadion_id: member.stadion_id });
       } catch (error) {
         errors.push({ knvb_id: member.knvb_id, message: error.message });
       }

       // Rate limit
       await sleep(2000);
     }

     return { deleted, errors };
   }
   ```

3. **Main runSync orchestration function:**
   ```javascript
   async function runSync(options = {}) {
     const { logger, verbose = false, force = false } = options;
     const logVerbose = logger?.verbose.bind(logger) || (verbose ? console.log : () => {});
     const logError = logger?.error.bind(logger) || console.error;

     const result = {
       success: true,
       total: 0,
       synced: 0,
       created: 0,
       updated: 0,
       skipped: 0,
       deleted: 0,
       errors: []
     };

     try {
       // Step 1: Prepare members from Sportlink
       const prepared = await runPrepare({ logger, verbose });
       if (!prepared.success) {
         result.success = false;
         result.error = prepared.error;
         return result;
       }

       const members = prepared.members;
       result.total = members.length;

       // Step 2: Upsert to tracking database
       const db = openDb();
       try {
         upsertMembers(db, members);

         // Step 3: Get members needing sync (hash changed or force)
         const needsSync = getMembersNeedingSync(db, force);
         result.skipped = result.total - needsSync.length;

         logVerbose(`${needsSync.length} members need sync (${result.skipped} unchanged)`);

         // Step 4: Sync each member
         for (let i = 0; i < needsSync.length; i++) {
           const member = needsSync[i];
           logVerbose(`Syncing ${i + 1}/${needsSync.length}: ${member.knvb_id}`);

           try {
             const syncResult = await syncPerson(member, db, options);
             result.synced++;
             if (syncResult.action === 'created') result.created++;
             if (syncResult.action === 'updated') result.updated++;
           } catch (error) {
             result.errors.push({
               knvb_id: member.knvb_id,
               email: member.email,
               message: error.message
             });
           }

           // Rate limit: 2 seconds between requests
           if (i < needsSync.length - 1) {
             await sleep(2000);
           }
         }

         // Step 5: Delete members removed from Sportlink
         const currentKnvbIds = members.map(m => m.knvb_id);
         const deleteResult = await deleteRemovedMembers(db, currentKnvbIds, options);
         result.deleted = deleteResult.deleted.length;
         result.errors.push(...deleteResult.errors);

       } finally {
         db.close();
       }

       result.success = result.errors.length === 0;
       return result;

     } catch (error) {
       result.success = false;
       result.error = error.message;
       logError(`Sync error: ${error.message}`);
       return result;
     }
   }
   ```

4. **CLI entry point:**
   ```javascript
   if (require.main === module) {
     const verbose = process.argv.includes('--verbose');
     const force = process.argv.includes('--force');

     runSync({ verbose, force })
       .then(result => {
         console.log(`Stadion sync: ${result.synced}/${result.total} synced`);
         console.log(`  Created: ${result.created}`);
         console.log(`  Updated: ${result.updated}`);
         console.log(`  Skipped: ${result.skipped}`);
         console.log(`  Deleted: ${result.deleted}`);
         if (result.errors.length > 0) {
           console.error(`  Errors: ${result.errors.length}`);
           result.errors.forEach(e => console.error(`    - ${e.knvb_id}: ${e.message}`));
           process.exitCode = 1;
         }
       })
       .catch(err => {
         console.error('Error:', err.message);
         process.exitCode = 1;
       });
   }
   ```

5. **Module exports:**
   ```javascript
   module.exports = { runSync };
   ```
  </action>
  <verify>
1. Run `node --check submit-stadion-sync.js` - syntax valid
2. Verify module loads: `node -e "require('./submit-stadion-sync')"`
3. Test CLI (will fail without Stadion credentials, but should show proper error):
   `node submit-stadion-sync.js --verbose`
4. Verify runSync is exported
  </verify>
  <done>
- deleteRemovedMembers function handles delete detection and execution
- runSync orchestrates full sync: prepare -> upsert -> sync changed -> delete removed
- Error collection continues sync on individual failures
- CLI shows sync summary with create/update/skip/delete counts
- runSync exported for pipeline integration
  </done>
</task>

<task type="auto">
  <name>Task 3: Add npm scripts for Stadion sync</name>
  <files>package.json</files>
  <action>
Add npm scripts for Stadion sync to package.json:

```json
{
  "scripts": {
    "sync-stadion": "node submit-stadion-sync.js",
    "sync-stadion-verbose": "node submit-stadion-sync.js --verbose"
  }
}
```

Add these to the existing scripts section, keeping all existing scripts intact.
  </action>
  <verify>
1. Run `npm run sync-stadion --help` or check package.json manually
2. Verify both scripts added: sync-stadion and sync-stadion-verbose
  </verify>
  <done>
- package.json has sync-stadion script
- package.json has sync-stadion-verbose script
  </done>
</task>

</tasks>

<verification>
1. All modules load without errors
2. npm run sync-stadion executes (may fail on credentials, but syntax OK)
3. Sync result includes: total, synced, created, updated, skipped, deleted, errors
4. Error handling: individual failures don't stop sync
5. Rate limiting: 2 second delay between API calls
6. Email fallback uses client-side filtering of ACF contact_info field
</verification>

<success_criteria>
- submit-stadion-sync.js created with runSync export
- Matching logic: KNVB ID first, email fallback with client-side ACF filtering
- Create, update, and delete operations all implemented
- Hash-based change detection skips unchanged members
- Sync continues after individual errors
- npm scripts added for running sync
</success_criteria>

<output>
After completion, create `.planning/phases/06-member-sync/06-03-SUMMARY.md`
</output>
