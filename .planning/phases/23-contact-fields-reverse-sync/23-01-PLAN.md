---
phase: 23-contact-fields-reverse-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/stadion-db.js
  - lib/reverse-sync-sportlink.js
  - reverse-sync-contact-fields.js
autonomous: true

must_haves:
  truths:
    - "System can query unsynced contact field changes from stadion_change_detections"
    - "System navigates to Sportlink member /general page and enters edit mode"
    - "System fills contact fields with values from Stadion change detection"
    - "System verifies field values were saved by reading them back"
    - "Successful syncs are marked in database to prevent re-processing"
  artifacts:
    - path: "lib/stadion-db.js"
      provides: "synced_at column migration and getUnsyncedContactChanges helper"
      contains: "synced_at"
    - path: "lib/reverse-sync-sportlink.js"
      provides: "Core reverse sync logic with Playwright automation"
      exports: ["syncMemberToSportlink", "runReverseSync"]
    - path: "reverse-sync-contact-fields.js"
      provides: "CLI entry point for reverse sync"
      min_lines: 30
  key_links:
    - from: "lib/reverse-sync-sportlink.js"
      to: "lib/stadion-db.js"
      via: "getUnsyncedContactChanges, markChangesSynced"
      pattern: "getUnsyncedContactChanges|markChangesSynced"
    - from: "lib/reverse-sync-sportlink.js"
      to: "playwright"
      via: "browser automation for Sportlink forms"
      pattern: "chromium\\.launch|page\\.fill"
---

<objective>
Implement core reverse sync functionality to push contact field changes (email, email2, mobile, phone) from Stadion to Sportlink via Playwright browser automation.

Purpose: Enable corrections made in Stadion to flow back to Sportlink, completing the bidirectional sync loop for contact fields.
Output: Working reverse sync module that navigates to Sportlink /general page, fills contact fields, verifies saves, and tracks synced changes.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-stadion-change-detection/22-01-SUMMARY.md

# Key source files
@lib/detect-stadion-changes.js
@lib/sync-origin.js
@lib/stadion-db.js
@download-data-from-sportlink.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database schema for reverse sync tracking</name>
  <files>lib/stadion-db.js</files>
  <action>
Add synced_at column to stadion_change_detections table for tracking which changes have been pushed to Sportlink.

In initDb(), after the existing stadion_change_detections table creation, add migration:

```javascript
// Add synced_at column for reverse sync tracking (Phase 23)
const changeDetectionColumns = db.prepare('PRAGMA table_info(stadion_change_detections)').all();
if (!changeDetectionColumns.some(col => col.name === 'synced_at')) {
  db.exec('ALTER TABLE stadion_change_detections ADD COLUMN synced_at TEXT');
}
```

Add two new helper functions:

1. `getUnsyncedContactChanges(db)` - Returns unsynced changes for contact fields only:
```javascript
function getUnsyncedContactChanges(db) {
  const stmt = db.prepare(`
    SELECT *
    FROM stadion_change_detections
    WHERE field_name IN ('email', 'email2', 'mobile', 'phone')
      AND synced_at IS NULL
    ORDER BY detected_at ASC
  `);
  return stmt.all();
}
```

2. `markChangesSynced(db, knvbId, fieldNames)` - Marks specific changes as synced:
```javascript
function markChangesSynced(db, knvbId, fieldNames) {
  const now = new Date().toISOString();
  const placeholders = fieldNames.map(() => '?').join(',');
  const stmt = db.prepare(`
    UPDATE stadion_change_detections
    SET synced_at = ?
    WHERE knvb_id = ?
      AND field_name IN (${placeholders})
      AND synced_at IS NULL
  `);
  stmt.run(now, knvbId, ...fieldNames);
}
```

Export both functions at the end of the file.
  </action>
  <verify>Run `node -e "const db = require('./lib/stadion-db'); const d = db.openDb(); console.log('synced_at column:', db.getUnsyncedContactChanges(d).length >= 0 ? 'OK' : 'FAIL'); d.close();"` - should output "synced_at column: OK"</verify>
  <done>stadion_change_detections has synced_at column, getUnsyncedContactChanges and markChangesSynced functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Create reverse sync module with Playwright automation</name>
  <files>lib/reverse-sync-sportlink.js</files>
  <action>
Create new module that handles Sportlink browser automation for contact field updates.

Structure:
1. Import dependencies: playwright, otplib, stadion-db helpers, sync-origin, logger
2. Define SPORTLINK_FIELD_MAP mapping detection field names to Sportlink form selectors
3. Implement loginToSportlink(page, credentials, options) - reuse pattern from download-data-from-sportlink.js
4. Implement syncMemberToSportlink(page, knvbId, fieldChanges, options) - navigate, edit, fill, save, verify
5. Implement syncMemberWithRetry(page, knvbId, fieldChanges, options) - exponential backoff wrapper
6. Implement runReverseSync(options) - main orchestration function

Key implementation details:

**SPORTLINK_FIELD_MAP** (need to be verified against actual Sportlink UI - use placeholder selectors):
```javascript
const SPORTLINK_FIELD_MAP = {
  'email': 'input[name="Email"]',      // Verify actual selector
  'email2': 'input[name="Email2"]',    // Verify actual selector
  'mobile': 'input[name="Mobile"]',    // Verify actual selector
  'phone': 'input[name="Phone"]'       // Verify actual selector
};
```

**loginToSportlink** - Extract from download-data-from-sportlink.js:
- Navigate to club.sportlink.com
- Fill username/password, click login
- Handle OTP via otplib
- Wait for dashboard selector

**syncMemberToSportlink**:
- Navigate to member URL: `https://club.sportlink.com/member/${knvbId}/general` (verify URL pattern)
- Enter edit mode (click edit button - selector TBD)
- For each changed field: fill with new_value using SPORTLINK_FIELD_MAP
- Click save button
- Wait for networkidle
- Read back each field value with page.inputValue() to verify save
- Throw error if any field verification fails

**syncMemberWithRetry** - 3 attempts with exponential backoff:
```javascript
async function syncMemberWithRetry(page, knvbId, fieldChanges, options = {}) {
  const { logger, maxRetries = 3 } = options;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      await syncMemberToSportlink(page, knvbId, fieldChanges, options);
      return { success: true, attempts: attempt + 1 };
    } catch (error) {
      if (attempt === maxRetries - 1) {
        return { success: false, attempts: attempt + 1, error: error.message };
      }
      const delay = 1000 * Math.pow(2, attempt) + Math.random() * 1000;
      logger?.verbose(`Retry ${attempt + 1}/${maxRetries} after ${Math.round(delay)}ms`);
      await new Promise(r => setTimeout(r, delay));
    }
  }
}
```

**runReverseSync(options)**:
1. Get unsynced contact changes via getUnsyncedContactChanges(db)
2. Group changes by knvb_id (Map)
3. If no changes, return early with { success: true, synced: 0, failed: 0 }
4. Launch Playwright browser, login to Sportlink
5. Process each member sequentially:
   - Call syncMemberWithRetry
   - On success: markChangesSynced(db, knvbId, fieldNames), update Sportlink timestamps
   - Add 1-2 second delay between members
6. Close browser
7. Return { success, synced, failed, results }

Export: { loginToSportlink, syncMemberToSportlink, runReverseSync }

Use module/CLI hybrid pattern but CLI entry point will be in separate file.
  </action>
  <verify>Run `node -e "const rs = require('./lib/reverse-sync-sportlink'); console.log('Exports:', Object.keys(rs).join(', '));"` - should show loginToSportlink, syncMemberToSportlink, runReverseSync</verify>
  <done>lib/reverse-sync-sportlink.js exports working functions for Sportlink automation</done>
</task>

<task type="auto">
  <name>Task 3: Create CLI entry point with verbose logging</name>
  <files>reverse-sync-contact-fields.js</files>
  <action>
Create CLI entry point following module/CLI hybrid pattern from download-data-from-sportlink.js.

```javascript
require('varlock/auto-load');

const { requireProductionServer } = require('./lib/server-check');
const { createSyncLogger } = require('./lib/logger');
const { runReverseSync } = require('./lib/reverse-sync-sportlink');

/**
 * Run contact fields reverse sync (Stadion -> Sportlink)
 * @param {Object} options
 * @param {boolean} [options.verbose=false] - Verbose mode
 * @returns {Promise<{success: boolean, synced: number, failed: number, results: Array}>}
 */
async function runContactFieldsReverseSync(options = {}) {
  const { verbose = false, logger: providedLogger } = options;
  const logger = providedLogger || createSyncLogger({ verbose, prefix: 'reverse' });

  logger.log('Starting contact fields reverse sync (Stadion -> Sportlink)...');

  try {
    const result = await runReverseSync({ verbose, logger });

    if (result.synced === 0 && result.failed === 0) {
      logger.log('No contact field changes to sync');
    } else {
      logger.log(`Reverse sync complete: ${result.synced} synced, ${result.failed} failed`);
    }

    return result;
  } catch (err) {
    logger.error(`Reverse sync failed: ${err.message}`);
    return { success: false, synced: 0, failed: 0, error: err.message };
  }
}

module.exports = { runContactFieldsReverseSync };

// CLI entry point
if (require.main === module) {
  // Prevent accidental local runs
  requireProductionServer({
    allowLocal: true,
    scriptName: 'reverse-sync-contact-fields.js'
  });

  const verbose = process.argv.includes('--verbose');

  runContactFieldsReverseSync({ verbose })
    .then(result => {
      if (!result.success) process.exitCode = 1;
    })
    .catch(err => {
      console.error('Error:', err.message);
      process.exitCode = 1;
    });
}
```

Note: allowLocal: true for development testing, but production server is the intended runtime.
  </action>
  <verify>Run `node reverse-sync-contact-fields.js --verbose 2>&1 | head -5` - should show startup message (will fail on login but that's expected without credentials)</verify>
  <done>reverse-sync-contact-fields.js provides CLI entry point with verbose logging and server check</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database schema test:
```bash
node -e "
  const db = require('./lib/stadion-db');
  const conn = db.openDb();
  const cols = conn.prepare('PRAGMA table_info(stadion_change_detections)').all();
  console.log('synced_at column exists:', cols.some(c => c.name === 'synced_at'));
  conn.close();
"
```

2. Module exports test:
```bash
node -e "
  const rs = require('./lib/reverse-sync-sportlink');
  console.log('loginToSportlink:', typeof rs.loginToSportlink);
  console.log('syncMemberToSportlink:', typeof rs.syncMemberToSportlink);
  console.log('runReverseSync:', typeof rs.runReverseSync);
"
```

3. CLI structure test:
```bash
node -e "const m = require('./reverse-sync-contact-fields'); console.log('export:', typeof m.runContactFieldsReverseSync);"
```
</verification>

<success_criteria>
- [ ] stadion_change_detections.synced_at column exists
- [ ] getUnsyncedContactChanges returns array of contact field changes with synced_at IS NULL
- [ ] markChangesSynced updates synced_at for specified changes
- [ ] lib/reverse-sync-sportlink.js exports loginToSportlink, syncMemberToSportlink, runReverseSync
- [ ] reverse-sync-contact-fields.js runs as CLI and exports runContactFieldsReverseSync
- [ ] Exponential backoff retry logic implemented (3 attempts max)
</success_criteria>

<output>
After completion, create `.planning/phases/23-contact-fields-reverse-sync/23-01-SUMMARY.md`
</output>
