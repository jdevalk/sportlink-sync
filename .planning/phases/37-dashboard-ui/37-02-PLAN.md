---
phase: 37-dashboard-ui
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - lib/dashboard-queries.js
  - views/errors.ejs
  - views/error-detail.ejs
  - lib/web-server.js
  - public/style.css
autonomous: false

must_haves:
  truths:
    - "Error browser lists all errors with filtering by pipeline and date range"
    - "Error drill-down shows individual member failures with error details"
    - "Dashboard is usable on a phone screen"
    - "All pages are responsive at mobile and tablet breakpoints"
  artifacts:
    - path: "views/errors.ejs"
      provides: "Error browser page with filter form and error list"
    - path: "views/error-detail.ejs"
      provides: "Error detail page showing member failures with stack traces"
    - path: "lib/dashboard-queries.js"
      provides: "getErrors and getRunErrors query functions"
      exports: ["getErrors", "getRunErrors"]
  key_links:
    - from: "lib/web-server.js"
      to: "lib/dashboard-queries.js"
      via: "getErrors/getRunErrors calls in route handlers"
      pattern: "getErrors|getRunErrors"
    - from: "views/errors.ejs"
      to: "/errors"
      via: "filter form submits GET with query params"
      pattern: "action.*errors"
    - from: "views/run-detail.ejs"
      to: "/errors?run_id=:id"
      via: "error count link on run detail page"
      pattern: "errors.*run_id"
---

<objective>
Build the error browser with filtering and drill-down, then polish responsive layout across all dashboard pages.

Purpose: Operators need to investigate sync failures without SSH. The error browser lets them filter errors by pipeline and date range, then drill down to see which members failed and why. Responsive polish ensures the dashboard works on phones for on-the-go monitoring.

Output: Error browser page, error detail view, and a responsive layout verified on mobile.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-dashboard-ui/37-01-SUMMARY.md
@lib/web-server.js
@lib/dashboard-queries.js
@lib/dashboard-db.js
@public/style.css
@views/partials/head.ejs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Error browser and error detail pages</name>
  <files>
    lib/dashboard-queries.js
    views/errors.ejs
    views/error-detail.ejs
    lib/web-server.js
    public/style.css
  </files>
  <action>
**1. Add query functions to `lib/dashboard-queries.js`**:

- `getErrors({ pipeline, dateFrom, dateTo, runId, page, perPage })` - Query `run_errors` with optional filters. Join with `runs` to get pipeline name. Build WHERE clause dynamically based on provided filters:
  - `pipeline` filter: `runs.pipeline = ?`
  - `dateFrom` filter: `run_errors.created_at >= ?`
  - `dateTo` filter: `run_errors.created_at <= ?` (add 'T23:59:59' to dateTo to include the full day)
  - `runId` filter: `run_errors.run_id = ?`
  - Always filter `runs.club_slug = 'rondo'`
  - Order by `run_errors.created_at DESC`
  - Return paginated results with total count.
  Each error row should include: id, run_id, step_name, member_identifier, error_message, created_at, and the pipeline name from the runs table.

- `getRunErrors(runId)` - Return all errors for a specific run: `SELECT * FROM run_errors WHERE run_id = ? ORDER BY created_at ASC`. Also return the run's pipeline and started_at for breadcrumb context.

**2. Create `views/errors.ejs`** - Error browser page. Structure:
- Include head/foot partials (page: 'errors')
- h2 "Error Browser"
- Filter form (GET /errors) with:
  - Pipeline dropdown: "All Pipelines" + the 6 pipelines. Pre-select based on query param.
  - Date from: `<input type="date">` pre-filled from query param
  - Date to: `<input type="date">` pre-filled from query param
  - "Filter" submit button
  - "Clear" link to `/errors`
- Below filters, show result count: "Showing X errors" or "No errors found"
- Error list as a table with columns: Time, Pipeline, Step, Member, Error Message
  - Time: formatted as "Feb 9, 14:00"
  - Pipeline: colored by pipeline name
  - Member: show member_identifier or "-" if null
  - Error Message: truncate to ~100 chars with ellipsis, full message on hover (title attribute)
  - Each row links to `/errors/:runId` to see all errors for that run
- Pagination at bottom (same style as run-history)
- If `run_id` query param present, show a banner: "Showing errors for Run #X" with link to clear filter

**3. Create `views/error-detail.ejs`** - Error detail for a specific run. Structure:
- Include head/foot partials
- Breadcrumb: "Overview > Pipeline > Run #X > Errors"
- h2 "Errors for Run #X"
- Run context: pipeline, started_at, outcome
- Error list (not paginated - show all errors for the run, typically <50):
  - Each error shown as a card with:
    - Step name (badge-style)
    - Member identifier (or "General error" if null)
    - Error message (full text, pre-formatted for readability)
    - Timestamp
    - Expandable stack trace if present (use `<details><summary>Stack trace</summary><pre>...</pre></details>`)

**4. Add routes to `lib/web-server.js`**:

- `GET /errors` - Parses query params: `pipeline`, `date_from`, `date_to`, `run_id`, `page`. Calls `getErrors(...)`. Renders `errors.ejs` with filter state, results, and pagination.

- `GET /errors/:runId` - Parses `:runId` as integer. Calls `getRunErrors(runId)`. If run not found, 404. Renders `error-detail.ejs`.

Both routes use `{ preHandler: requireAuth }`.

**5. Add styles to `public/style.css`**:
- `.filter-bar` - Flex row, gap 1rem, margin-bottom 1.5rem, flex-wrap for mobile
- `.filter-bar input, .filter-bar select` - Padding 0.5rem, border 1px solid #dee2e6, border-radius 4px
- `.filter-bar button` - Background #007bff, color white, padding 0.5rem 1rem, border-radius 4px
- `.filter-bar .btn-clear` - Background transparent, color #6c757d
- `.error-card` - Background white, border-left 4px solid #dc3545, padding 1rem, margin-bottom 1rem, border-radius 0 4px 4px 0
- `.error-card .step-badge` - Inline-block, background #e9ecef, padding 0.25rem 0.5rem, border-radius 4px, font-size 0.85rem
- `.error-card .member-id` - Font-weight 600
- `.error-card .error-message` - Margin-top 0.5rem, font-family monospace, font-size 0.9rem, white-space pre-wrap, word-break break-word
- `.error-card details summary` - Cursor pointer, color #6c757d, font-size 0.85rem
- `.error-card details pre` - Background #f8f9fa, padding 0.75rem, overflow-x auto, font-size 0.8rem, margin-top 0.5rem
- `.banner` - Background #e2e3e5, padding 0.75rem 1rem, border-radius 4px, margin-bottom 1rem, display flex, justify-content space-between, align-items center
- On mobile (<768px): `.filter-bar` column direction, `.filter-bar input, .filter-bar select` full width
  </action>
  <verify>
    Run `node -e "const q = require('./lib/dashboard-queries'); console.log(typeof q.getErrors, typeof q.getRunErrors)"` to verify new exports.
    Run `node -e "const {buildServer} = require('./lib/web-server'); buildServer().then(s => s.close())"` to verify server builds.
    Verify views/errors.ejs exists and contains 'filter-bar' class.
    Verify views/error-detail.ejs exists and contains 'error-card' class.
    Check that GET /errors and GET /errors/:runId routes exist in web-server.js.
  </verify>
  <done>
    Error browser page shows filterable list of errors by pipeline and date range. Error detail page shows all errors for a run with expandable stack traces. Filter form preserves selected values. Pagination works. Run detail page links to error view when errors exist.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete dashboard UI with 5 pages: pipeline overview (traffic-light cards), run history (paginated table), run detail (step breakdown), error browser (filtered list), and error detail (member failures with stack traces). All pages are responsive with shared layout.
  </what-built>
  <how-to-verify>
    1. SSH to the production server: `ssh root@46.202.155.16`
    2. Deploy the code: `cd /home/sportlink && git pull && systemctl restart rondo-sync-web`
    3. Open https://sync.rondo.club in a browser and log in
    4. Verify the pipeline overview page shows 6 pipeline cards with traffic-light status
    5. Click a pipeline card (e.g., "People") to see run history with pagination
    6. Click a run to see per-step breakdown with counts
    7. Click "Errors" in the navigation to see the error browser
    8. Test filters: select a pipeline, set date range, click Filter
    9. If errors exist, click through to error detail and verify stack traces expand
    10. Test on a phone (or resize browser to ~375px width):
        - Pipeline cards should stack to 1 column
        - Tables should scroll horizontally
        - Filter bar should stack vertically
        - Navigation should remain accessible
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the dashboard layout, navigation, or data display.</resume-signal>
</task>

</tasks>

<verification>
1. `node -e "const {buildServer} = require('./lib/web-server'); buildServer().then(s => s.close())"` succeeds
2. All view files exist: errors.ejs, error-detail.ejs
3. `public/style.css` contains filter-bar, error-card, banner classes
4. Routes registered: GET /errors, GET /errors/:runId (with requireAuth)
5. Error browser filter form works with pipeline and date range params
6. Dashboard is visually verified on phone screen by user
</verification>

<success_criteria>
- Error browser lists errors with filtering by pipeline and date range
- Error drill-down shows individual member failures with error details and stack traces
- All dashboard pages are usable on a phone screen (responsive layout)
- User has visually verified the complete dashboard on desktop and mobile
</success_criteria>

<output>
After completion, create `.planning/phases/37-dashboard-ui/37-02-SUMMARY.md`
</output>
