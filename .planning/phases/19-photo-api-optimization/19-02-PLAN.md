---
phase: 19-photo-api-optimization
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - download-photos-from-api.js
  - lib/stadion-db.js
autonomous: true

must_haves:
  truths:
    - "Photos are downloaded via direct HTTP fetch from Photo.Url"
    - "Download includes retry logic (2-3 attempts) on failures"
    - "Members without photos are handled gracefully (no errors)"
    - "Downloaded photos are saved to photos/ directory with correct extension"
  artifacts:
    - path: "download-photos-from-api.js"
      provides: "HTTP-based photo download replacing browser automation"
      exports: ["runPhotoDownload"]
      min_lines: 100
    - path: "lib/stadion-db.js"
      provides: "getMembersNeedingPhotoDownload() query"
      contains: "getMembersNeedingPhotoDownload"
  key_links:
    - from: "download-photos-from-api.js"
      to: "lib/stadion-db.js"
      via: "getMembersNeedingPhotoDownload()"
      pattern: "getMembersNeedingPhotoDownload"
---

<objective>
Create HTTP-based photo download script that replaces browser automation.

Purpose: Replace the slow, brittle browser-based photo download (download-photos-from-sportlink.js) with direct HTTP fetch using photo_url from database. This eliminates Playwright dependency for photos and reduces download time by 5-35x.

Output: New download-photos-from-api.js script with HTTP fetch, retry logic, and proper error handling.
</objective>

<execution_context>
@/Users/joostdevalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/joostdevalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-photo-api-optimization/19-01-PLAN.md
@.planning/phases/19-photo-api-optimization/19-CONTEXT.md
@.planning/phases/19-photo-api-optimization/19-RESEARCH.md
@download-photos-from-sportlink.js (existing browser-based script to replace)
@upload-photos-to-stadion.js (existing upload script - keep unchanged)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database function to get members needing photo download</name>
  <files>lib/stadion-db.js</files>
  <action>
Add a new function getMembersNeedingPhotoDownload() that returns members with:
- photo_state = 'pending_download'
- photo_url IS NOT NULL

This is different from getMembersByPhotoState() because it also includes photo_url in the result.

Add near the other photo-related functions (around line 700):

```javascript
/**
 * Get members needing photo download with their photo URLs
 * @param {Object} db - SQLite database connection
 * @returns {Array<{knvb_id: string, photo_url: string, photo_date: string, stadion_id: number}>}
 */
function getMembersNeedingPhotoDownload(db) {
  const stmt = db.prepare(`
    SELECT knvb_id, photo_url, photo_date, stadion_id
    FROM stadion_members
    WHERE photo_state = 'pending_download'
      AND photo_url IS NOT NULL
    ORDER BY knvb_id ASC
  `);
  return stmt.all();
}
```

Export the function in module.exports at the bottom of the file.
  </action>
  <verify>
Run: `node -c lib/stadion-db.js` - syntax check passes
Grep for "getMembersNeedingPhotoDownload" to confirm function exists
Check module.exports includes the new function
  </verify>
  <done>
getMembersNeedingPhotoDownload() function returns members with pending_download state and valid photo_url.
Function is exported for use by photo download script.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP-based photo download script</name>
  <files>download-photos-from-api.js</files>
  <action>
Create new file download-photos-from-api.js with HTTP-based photo download.

Key implementation details:

1. **Module structure:** Follow existing pattern (module/CLI hybrid)
```javascript
require('varlock/auto-load');

const fs = require('fs/promises');
const path = require('path');
const { openDb, getMembersNeedingPhotoDownload, updatePhotoState } = require('./lib/stadion-db');
const { createSyncLogger } = require('./lib/logger');
```

2. **MIME type handling:** Reuse from existing script
```javascript
const MIME_TO_EXT = {
  'image/jpeg': 'jpg',
  'image/jpg': 'jpg',
  'image/png': 'png',
  'image/webp': 'webp',
  'image/gif': 'gif'
};

function mimeToExtension(contentType) {
  const baseType = (contentType || '').split(';')[0].trim().toLowerCase();
  return MIME_TO_EXT[baseType] || 'jpg';
}
```

3. **Photo download function with retry:**
```javascript
async function downloadPhotoFromUrl(photoUrl, knvbId, photosDir, logger, retries = 3) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const response = await fetch(photoUrl, {
        signal: AbortSignal.timeout(10000) // 10 second timeout
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const buffer = Buffer.from(await response.arrayBuffer());

      // Validate we got actual image data
      if (buffer.length < 100) {
        throw new Error('Invalid image data (too small)');
      }

      const contentType = response.headers.get('content-type');
      const ext = mimeToExtension(contentType);

      const filepath = path.join(photosDir, `${knvbId}.${ext}`);
      await fs.writeFile(filepath, buffer);

      return { success: true, path: filepath, bytes: buffer.length };
    } catch (error) {
      logger.verbose(`  Attempt ${attempt}/${retries} failed: ${error.message}`);
      if (attempt === retries) {
        throw error;
      }
      // Exponential backoff
      await new Promise(r => setTimeout(r, 1000 * attempt));
    }
  }
}
```

4. **Main orchestration function:**
```javascript
async function runPhotoDownload(options = {}) {
  const { logger: providedLogger, verbose = false, force = false } = options;
  const logger = providedLogger || createSyncLogger({ verbose });

  const result = {
    success: true,
    total: 0,
    downloaded: 0,
    skipped: 0,  // Members with no photo_url
    failed: 0,
    errors: []
  };

  const db = openDb();
  try {
    const members = getMembersNeedingPhotoDownload(db);
    result.total = members.length;

    if (members.length === 0) {
      logger.log('No photos pending download');
      return result;
    }

    logger.log(`${members.length} photos pending download`);

    const photosDir = path.join(process.cwd(), 'photos');
    await fs.mkdir(photosDir, { recursive: true });

    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      logger.verbose(`Downloading photo ${i + 1}/${members.length}: ${member.knvb_id}`);

      try {
        const downloadResult = await downloadPhotoFromUrl(
          member.photo_url,
          member.knvb_id,
          photosDir,
          logger
        );

        updatePhotoState(db, member.knvb_id, 'downloaded');
        result.downloaded++;
        logger.verbose(`  Saved ${path.basename(downloadResult.path)} (${downloadResult.bytes} bytes)`);
      } catch (error) {
        result.failed++;
        result.errors.push({ knvb_id: member.knvb_id, message: error.message });
        logger.verbose(`  Failed: ${error.message}`);
        // Continue to next member - don't change photo_state
      }

      // Small delay between downloads (rate limiting)
      if (i < members.length - 1) {
        await new Promise(r => setTimeout(r, 200));
      }
    }

    logger.log(`Downloaded ${result.downloaded}/${result.total} photos`);
    if (result.failed > 0) {
      logger.log(`Failed: ${result.failed}`);
    }

    result.success = result.failed === 0;
    return result;
  } finally {
    db.close();
  }
}

module.exports = { runPhotoDownload };

// CLI entry point
if (require.main === module) {
  const verbose = process.argv.includes('--verbose');
  runPhotoDownload({ verbose })
    .then(result => {
      if (!result.success) process.exitCode = 1;
    })
    .catch(err => {
      console.error('Error:', err.message);
      process.exitCode = 1;
    });
}
```

Key differences from browser-based script:
- No Playwright/Chromium dependency
- No login required (direct URL access)
- Built-in retry with exponential backoff
- 10 second timeout per request
- Validates image data size
- Much faster (no page navigation)
  </action>
  <verify>
Run: `node -c download-photos-from-api.js` - syntax check passes
Confirm exports runPhotoDownload
Confirm fetch with retry logic implemented
Confirm MIME type handling present
  </verify>
  <done>
New download-photos-from-api.js created with HTTP-based photo download.
Retry logic (3 attempts with exponential backoff) implemented.
Photo validation (minimum size check) included.
Module exports runPhotoDownload for integration.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `node -c lib/stadion-db.js` - no syntax errors
2. `node -c download-photos-from-api.js` - no syntax errors
3. getMembersNeedingPhotoDownload() function exists and is exported
4. download-photos-from-api.js has no Playwright imports
5. Retry logic with 3 attempts is present
6. MIME type to extension mapping included
7. 10 second timeout configured
</verification>

<success_criteria>
- getMembersNeedingPhotoDownload() returns pending photos with URLs
- download-photos-from-api.js downloads photos via HTTP fetch
- Retry logic handles transient failures (2-3 attempts)
- Image validation rejects invalid/empty data
- Photos saved with correct extension based on MIME type
- No Playwright dependency in new script
- Both files pass syntax checks
</success_criteria>

<output>
After completion, create `.planning/phases/19-photo-api-optimization/19-02-SUMMARY.md`
</output>
